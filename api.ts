/* tslint:disable */
/* eslint-disable */
/**
 * Gridly API
 * Gridly API documentation
 *
 * The version of the OpenAPI document: 4.33.0
 * Contact: support@gridly.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddViewColumn
 */
export interface AddViewColumn {
    /**
     * 
     * @type {string}
     * @memberof AddViewColumn
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddViewColumn
     */
    'editable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AddViewColumn
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddViewColumn
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddViewColumn
     */
    'type'?: AddViewColumnTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AddViewColumn
     */
    'languageCode'?: AddViewColumnLanguageCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof AddViewColumn
     */
    'localizationType'?: AddViewColumnLocalizationTypeEnum;
    /**
     * 
     * @type {NumberFormat}
     * @memberof AddViewColumn
     */
    'numberFormat'?: NumberFormat;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddViewColumn
     */
    'selectionOptions'?: Array<string>;
    /**
     * 
     * @type {Reference}
     * @memberof AddViewColumn
     */
    'reference'?: Reference;
    /**
     * 
     * @type {Formula}
     * @memberof AddViewColumn
     */
    'formula'?: Formula;
    /**
     * 
     * @type {DateTimeFormat}
     * @memberof AddViewColumn
     */
    'dateTimeFormat'?: DateTimeFormat;
}

export const AddViewColumnTypeEnum = {
    SingleLine: 'singleLine',
    MultipleLines: 'multipleLines',
    RichText: 'richText',
    Markdown: 'markdown',
    SingleSelection: 'singleSelection',
    MultipleSelections: 'multipleSelections',
    Boolean: 'boolean',
    Number: 'number',
    Datetime: 'datetime',
    Files: 'files',
    Reference: 'reference',
    Lookup: 'lookup',
    Language: 'language',
    Json: 'json',
    Yaml: 'yaml',
    Html: 'html',
    Formula: 'formula'
} as const;

export type AddViewColumnTypeEnum = typeof AddViewColumnTypeEnum[keyof typeof AddViewColumnTypeEnum];
export const AddViewColumnLanguageCodeEnum = {
    EnUs: 'enUS',
    ArSa: 'arSA',
    CaEs: 'caES',
    ZhCn: 'zhCN',
    ZhTw: 'zhTW',
    DeDe: 'deDE',
    ItIt: 'itIT',
    JaJp: 'jaJP',
    KoKr: 'koKR',
    PlPl: 'plPL',
    PtAo: 'ptAO',
    PtBr: 'ptBR',
    RuRu: 'ruRU',
    EsMx: 'esMX',
    EsLa: 'esLA',
    EsEs: 'esES',
    BnBd: 'bnBD',
    BgBg: 'bgBG',
    ZhHk: 'zhHK',
    CsCz: 'csCZ',
    DaDk: 'daDK',
    NlNl: 'nlNL',
    FiFi: 'fiFI',
    FrFr: 'frFR',
    FrCa: 'frCA',
    ElGr: 'elGR',
    HeIl: 'heIL',
    HiIn: 'hiIN',
    HuHu: 'huHU',
    IdId: 'idID',
    JwId: 'jwID',
    LvLv: 'lvLV',
    MsMy: 'msMY',
    NoNo: 'noNO',
    PtPt: 'ptPT',
    RoRo: 'roRO',
    SkSk: 'skSK',
    SvSe: 'svSE',
    TlPh: 'tlPH',
    ThTh: 'thTH',
    TrTr: 'trTR',
    UkUa: 'ukUA',
    UrIn: 'urIN',
    ViVn: 'viVN',
    AfZa: 'afZA',
    ArAe: 'arAE',
    ArBh: 'arBH',
    ArDz: 'arDZ',
    ArEg: 'arEG',
    ArIq: 'arIQ',
    ArJo: 'arJO',
    ArKw: 'arKW',
    ArLb: 'arLB',
    ArLy: 'arLY',
    ArMa: 'arMA',
    ArOm: 'arOM',
    ArQa: 'arQA',
    ArSy: 'arSY',
    ArTn: 'arTN',
    ArYe: 'arYE',
    AzAz: 'azAZ',
    BeBy: 'beBY',
    BsBa: 'bsBA',
    CyGb: 'cyGB',
    DeAt: 'deAT',
    DeCh: 'deCH',
    DeLi: 'deLI',
    DeLu: 'deLU',
    DvMv: 'dvMV',
    EnAu: 'enAU',
    EnBz: 'enBZ',
    EnCa: 'enCA',
    EnGb: 'enGB',
    EnIe: 'enIE',
    EnJm: 'enJM',
    EnNz: 'enNZ',
    EnPh: 'enPH',
    EnTt: 'enTT',
    EnZa: 'enZA',
    EnZw: 'enZW',
    EnSg: 'enSG',
    EnIn: 'enIN',
    EnGh: 'enGH',
    EnRw: 'enRW',
    EnZm: 'enZM',
    EnKe: 'enKE',
    EnNg: 'enNG',
    EsAr: 'esAR',
    EsBo: 'esBO',
    EsCl: 'esCL',
    EsCo: 'esCO',
    EsCr: 'esCR',
    EsDo: 'esDO',
    EsEc: 'esEC',
    EsGt: 'esGT',
    EsHn: 'esHN',
    EsNi: 'esNI',
    EsPa: 'esPA',
    EsPe: 'esPE',
    EsPr: 'esPR',
    EsPy: 'esPY',
    EsSv: 'esSV',
    EsUy: 'esUY',
    EsVe: 'esVE',
    EtEe: 'etEE',
    EuEs: 'euES',
    FaIr: 'faIR',
    FoFo: 'foFO',
    FrBe: 'frBE',
    FrCh: 'frCH',
    FrLu: 'frLU',
    FrMc: 'frMC',
    GlEs: 'glES',
    GuIn: 'guIN',
    HrBa: 'hrBA',
    HrHr: 'hrHR',
    HyAm: 'hyAM',
    IsIs: 'isIS',
    ItCh: 'itCH',
    KaGe: 'kaGE',
    KkKz: 'kkKZ',
    KnIn: 'knIN',
    KokIn: 'kokIN',
    KyKg: 'kyKG',
    LtLt: 'ltLT',
    MiNz: 'miNZ',
    MkMk: 'mkMK',
    MnMn: 'mnMN',
    MrIn: 'mrIN',
    MsBn: 'msBN',
    MtMt: 'mtMT',
    NbNo: 'nbNO',
    NlBe: 'nlBE',
    NnNo: 'nnNO',
    NsZa: 'nsZA',
    PaIn: 'paIN',
    PsAr: 'psAR',
    QuBo: 'quBO',
    QuEc: 'quEC',
    QuPe: 'quPE',
    SaIn: 'saIN',
    SeFi: 'seFI',
    SeNo: 'seNO',
    SeSe: 'seSE',
    SlSi: 'slSI',
    SqAl: 'sqAL',
    SrBa: 'srBA',
    SrRs: 'srRS',
    SrMe: 'srME',
    SvFi: 'svFI',
    SwKe: 'swKE',
    SyrSy: 'syrSY',
    TaIn: 'taIN',
    TeIn: 'teIN',
    TnZa: 'tnZA',
    TtRu: 'ttRU',
    UrPk: 'urPK',
    UzUz: 'uzUZ',
    XhZa: 'xhZA',
    ZhMo: 'zhMO',
    ZhSg: 'zhSG',
    ZuZa: 'zuZA',
    Am: 'am',
    Hy: 'hy',
    Az: 'az',
    Bn: 'bn',
    Bs: 'bs',
    Ca: 'ca',
    Hr: 'hr',
    Da: 'da',
    Nl: 'nl',
    En: 'en',
    Fi: 'fi',
    Fr: 'fr',
    Hi: 'hi',
    Hu: 'hu',
    Id: 'id',
    It: 'it',
    Km: 'km',
    Mi: 'mi',
    Ps: 'ps',
    Ru: 'ru',
    Sl: 'sl',
    Es: 'es',
    Sw: 'sw',
    Ta: 'ta',
    Ur: 'ur',
    Af: 'af',
    Et: 'et',
    Gl: 'gl',
    Ja: 'ja',
    Kk: 'kk',
    Ky: 'ky',
    Mk: 'mk',
    Ms: 'ms',
    Se: 'se',
    Pl: 'pl',
    Pa: 'pa',
    Ro: 'ro',
    Sk: 'sk',
    Sv: 'sv',
    Tt: 'tt',
    Te: 'te',
    Tr: 'tr',
    Uz: 'uz',
    Vi: 'vi',
    Eu: 'eu',
    Be: 'be',
    Cs: 'cs',
    De: 'de',
    Gu: 'gu',
    He: 'he',
    Is: 'is',
    Ko: 'ko',
    Lt: 'lt',
    Mr: 'mr',
    Mn: 'mn',
    Nb: 'nb',
    Nn: 'nn',
    Pt: 'pt',
    Sa: 'sa',
    Tn: 'tn',
    Uk: 'uk',
    Xh: 'xh',
    Sq: 'sq',
    Ar: 'ar',
    Bg: 'bg',
    Zh: 'zh',
    Dv: 'dv',
    Fo: 'fo',
    Fa: 'fa',
    Ka: 'ka',
    El: 'el',
    Kn: 'kn',
    Lv: 'lv',
    Mt: 'mt',
    Qu: 'qu',
    Sr: 'sr',
    Si: 'si',
    Tl: 'tl',
    Th: 'th',
    Cy: 'cy',
    Zu: 'zu',
    No: 'no'
} as const;

export type AddViewColumnLanguageCodeEnum = typeof AddViewColumnLanguageCodeEnum[keyof typeof AddViewColumnLanguageCodeEnum];
export const AddViewColumnLocalizationTypeEnum = {
    SourceLanguage: 'sourceLanguage',
    TargetLanguage: 'targetLanguage'
} as const;

export type AddViewColumnLocalizationTypeEnum = typeof AddViewColumnLocalizationTypeEnum[keyof typeof AddViewColumnLocalizationTypeEnum];

/**
 * 
 * @export
 * @interface Branch
 */
export interface Branch {
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'id'?: string;
    /**
     * 
     * @type {Array<ViewColumn>}
     * @memberof Branch
     */
    'columns'?: Array<ViewColumn>;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'defaultAccessViewId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Branch
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'recordIdentifierType'?: BranchRecordIdentifierTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'status'?: BranchStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Branch
     */
    'isMaster'?: boolean;
}

export const BranchRecordIdentifierTypeEnum = {
    RecordId: 'recordId',
    PathTagRecordId: 'pathTagRecordId'
} as const;

export type BranchRecordIdentifierTypeEnum = typeof BranchRecordIdentifierTypeEnum[keyof typeof BranchRecordIdentifierTypeEnum];
export const BranchStatusEnum = {
    Deleted: 'deleted',
    Active: 'active',
    Inactive: 'inactive',
    Restoring: 'restoring',
    BackingUp: 'backingUp',
    Uploading: 'uploading',
    Importing: 'importing',
    Branching: 'branching',
    Merging: 'merging',
    Duplicating: 'duplicating',
    ClearingRecords: 'clearingRecords',
    Copying: 'copying'
} as const;

export type BranchStatusEnum = typeof BranchStatusEnum[keyof typeof BranchStatusEnum];

/**
 * 
 * @export
 * @interface BranchDiffCell
 */
export interface BranchDiffCell {
    /**
     * 
     * @type {string}
     * @memberof BranchDiffCell
     */
    'sourceDependencyStatus'?: BranchDiffCellSourceDependencyStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BranchDiffCell
     */
    'destinationDependencyStatus'?: BranchDiffCellDestinationDependencyStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BranchDiffCell
     */
    'sourceSourceStatus'?: BranchDiffCellSourceSourceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BranchDiffCell
     */
    'destinationSourceStatus'?: BranchDiffCellDestinationSourceStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof BranchDiffCell
     */
    'sourceLengthSetting'?: number;
    /**
     * 
     * @type {number}
     * @memberof BranchDiffCell
     */
    'destinationLengthSetting'?: number;
    /**
     * 
     * @type {string}
     * @memberof BranchDiffCell
     */
    'status'?: BranchDiffCellStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BranchDiffCell
     */
    'columnId'?: string;
    /**
     * 
     * @type {object}
     * @memberof BranchDiffCell
     */
    'sourceValue'?: object;
    /**
     * 
     * @type {object}
     * @memberof BranchDiffCell
     */
    'destinationValue'?: object;
}

export const BranchDiffCellSourceDependencyStatusEnum = {
    UpToDate: 'upToDate',
    OutOfDate: 'outOfDate',
    Unset: 'unset'
} as const;

export type BranchDiffCellSourceDependencyStatusEnum = typeof BranchDiffCellSourceDependencyStatusEnum[keyof typeof BranchDiffCellSourceDependencyStatusEnum];
export const BranchDiffCellDestinationDependencyStatusEnum = {
    UpToDate: 'upToDate',
    OutOfDate: 'outOfDate',
    Unset: 'unset'
} as const;

export type BranchDiffCellDestinationDependencyStatusEnum = typeof BranchDiffCellDestinationDependencyStatusEnum[keyof typeof BranchDiffCellDestinationDependencyStatusEnum];
export const BranchDiffCellSourceSourceStatusEnum = {
    Unset: 'unset',
    DoNotTranslate: 'doNotTranslate',
    NotReadyForTranslation: 'notReadyForTranslation',
    ReadyForTranslation: 'readyForTranslation',
    Locked: 'locked',
    LockAllLanguages: 'lockAllLanguages'
} as const;

export type BranchDiffCellSourceSourceStatusEnum = typeof BranchDiffCellSourceSourceStatusEnum[keyof typeof BranchDiffCellSourceSourceStatusEnum];
export const BranchDiffCellDestinationSourceStatusEnum = {
    Unset: 'unset',
    DoNotTranslate: 'doNotTranslate',
    NotReadyForTranslation: 'notReadyForTranslation',
    ReadyForTranslation: 'readyForTranslation',
    Locked: 'locked',
    LockAllLanguages: 'lockAllLanguages'
} as const;

export type BranchDiffCellDestinationSourceStatusEnum = typeof BranchDiffCellDestinationSourceStatusEnum[keyof typeof BranchDiffCellDestinationSourceStatusEnum];
export const BranchDiffCellStatusEnum = {
    Behind: 'behind',
    Ahead: 'ahead',
    Conflicted: 'conflicted',
    Unchanged: 'unchanged',
    InvalidData: 'invalidData',
    Na: 'na',
    Empty: 'empty',
    TargetTranslationEmpty: 'targetTranslationEmpty',
    TranslationNotReady: 'translationNotReady',
    TranslationNotFound: 'translationNotFound',
    SourceTargetMismatched: 'sourceTargetMismatched',
    TargetChangedTmNotApproved: 'targetChangedTMNotApproved',
    TargetNotChanged: 'targetNotChanged',
    SourcedChanged: 'sourcedChanged',
    TargetChanged: 'targetChanged',
    TextOverLength: 'textOverLength',
    TranslationNotChanged: 'translationNotChanged',
    NotChanged: 'notChanged',
    WarningOff: 'warningOff'
} as const;

export type BranchDiffCellStatusEnum = typeof BranchDiffCellStatusEnum[keyof typeof BranchDiffCellStatusEnum];

/**
 * 
 * @export
 * @interface BranchDiffRecord
 */
export interface BranchDiffRecord {
    /**
     * 
     * @type {string}
     * @memberof BranchDiffRecord
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BranchDiffRecord
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof BranchDiffRecord
     */
    'status'?: BranchDiffRecordStatusEnum;
    /**
     * 
     * @type {Array<BranchDiffCell>}
     * @memberof BranchDiffRecord
     */
    'cells'?: Array<BranchDiffCell>;
    /**
     * 
     * @type {string}
     * @memberof BranchDiffRecord
     */
    'lastModifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof BranchDiffRecord
     */
    'lastModifiedTime'?: string;
}

export const BranchDiffRecordStatusEnum = {
    Added: 'added',
    Updated: 'updated',
    Deleted: 'deleted',
    Duplicated: 'duplicated',
    ExceededLengthId: 'exceededLengthId',
    Merged: 'merged',
    IdentifierUpdated: 'identifierUpdated'
} as const;

export type BranchDiffRecordStatusEnum = typeof BranchDiffRecordStatusEnum[keyof typeof BranchDiffRecordStatusEnum];

/**
 * 
 * @export
 * @interface Cell
 */
export interface Cell {
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    'columnId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    'dependencyStatus'?: CellDependencyStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    'lengthLimit'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Cell
     */
    'referencedIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    'sourceStatus'?: CellSourceStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Cell
     */
    'tm'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof Cell
     */
    'value'?: any;
}

export const CellDependencyStatusEnum = {
    UpToDate: 'upToDate',
    OutOfDate: 'outOfDate',
    Unset: 'unset'
} as const;

export type CellDependencyStatusEnum = typeof CellDependencyStatusEnum[keyof typeof CellDependencyStatusEnum];
export const CellSourceStatusEnum = {
    Unset: 'unset',
    DoNotTranslate: 'doNotTranslate',
    NotReadyForTranslation: 'notReadyForTranslation',
    ReadyForTranslation: 'readyForTranslation',
    Locked: 'locked',
    LockAllLanguages: 'lockAllLanguages'
} as const;

export type CellSourceStatusEnum = typeof CellSourceStatusEnum[keyof typeof CellSourceStatusEnum];

/**
 * 
 * @export
 * @interface CellHistory
 */
export interface CellHistory {
    /**
     * 
     * @type {string}
     * @memberof CellHistory
     */
    'dependencyStatus'?: CellHistoryDependencyStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CellHistory
     */
    'sourceStatus'?: CellHistorySourceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CellHistory
     */
    'columnId'?: string;
    /**
     * 
     * @type {object}
     * @memberof CellHistory
     */
    'value'?: object;
}

export const CellHistoryDependencyStatusEnum = {
    UpToDate: 'upToDate',
    OutOfDate: 'outOfDate',
    Unset: 'unset'
} as const;

export type CellHistoryDependencyStatusEnum = typeof CellHistoryDependencyStatusEnum[keyof typeof CellHistoryDependencyStatusEnum];
export const CellHistorySourceStatusEnum = {
    Unset: 'unset',
    DoNotTranslate: 'doNotTranslate',
    NotReadyForTranslation: 'notReadyForTranslation',
    ReadyForTranslation: 'readyForTranslation',
    Locked: 'locked',
    LockAllLanguages: 'lockAllLanguages'
} as const;

export type CellHistorySourceStatusEnum = typeof CellHistorySourceStatusEnum[keyof typeof CellHistorySourceStatusEnum];

/**
 * 
 * @export
 * @interface ColumnReference
 */
export interface ColumnReference {
    /**
     * 
     * @type {ReferencedGrid}
     * @memberof ColumnReference
     */
    'grid'?: ReferencedGrid;
    /**
     * 
     * @type {ReferencedColumn}
     * @memberof ColumnReference
     */
    'column'?: ReferencedColumn;
    /**
     * 
     * @type {ReferencedGrid}
     * @memberof ColumnReference
     */
    'branch'?: ReferencedGrid;
    /**
     * 
     * @type {string}
     * @memberof ColumnReference
     */
    'type'?: ColumnReferenceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ColumnReference
     */
    'selectionType'?: ColumnReferenceSelectionTypeEnum;
}

export const ColumnReferenceTypeEnum = {
    Row: 'ROW',
    Cell: 'CELL'
} as const;

export type ColumnReferenceTypeEnum = typeof ColumnReferenceTypeEnum[keyof typeof ColumnReferenceTypeEnum];
export const ColumnReferenceSelectionTypeEnum = {
    Single: 'SINGLE',
    Multiple: 'MULTIPLE'
} as const;

export type ColumnReferenceSelectionTypeEnum = typeof ColumnReferenceSelectionTypeEnum[keyof typeof ColumnReferenceSelectionTypeEnum];

/**
 * 
 * @export
 * @interface ColumnStatistic
 */
export interface ColumnStatistic {
    /**
     * 
     * @type {TranslationCount}
     * @memberof ColumnStatistic
     */
    'recordCount'?: TranslationCount;
    /**
     * 
     * @type {TranslationCount}
     * @memberof ColumnStatistic
     */
    'wordCount'?: TranslationCount;
}
/**
 * 
 * @export
 * @interface CreateBranch
 */
export interface CreateBranch {
    /**
     * 
     * @type {string}
     * @memberof CreateBranch
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBranch
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof CreateBranch
     */
    'customProperties'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof CreateBranch
     */
    'inheritGroupAccess'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBranch
     */
    'inheritAutomation'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateBranch
     */
    'viewId'?: string;
}
/**
 * 
 * @export
 * @interface CreateColumn
 */
export interface CreateColumn {
    /**
     * 
     * @type {string}
     * @memberof CreateColumn
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateColumn
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateColumn
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateColumn
     */
    'type': CreateColumnTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CreateColumn
     */
    'editable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateColumn
     */
    'languageCode'?: CreateColumnLanguageCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateColumn
     */
    'localizationType'?: CreateColumnLocalizationTypeEnum;
    /**
     * 
     * @type {NumberFormat}
     * @memberof CreateColumn
     */
    'numberFormat'?: NumberFormat;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateColumn
     */
    'selectionOptions'?: Array<string>;
    /**
     * 
     * @type {Reference}
     * @memberof CreateColumn
     */
    'reference'?: Reference;
    /**
     * 
     * @type {Formula}
     * @memberof CreateColumn
     */
    'formula'?: Formula;
    /**
     * 
     * @type {DateTimeFormat}
     * @memberof CreateColumn
     */
    'dateTimeFormat'?: DateTimeFormat;
}

export const CreateColumnTypeEnum = {
    SingleLine: 'singleLine',
    MultipleLines: 'multipleLines',
    RichText: 'richText',
    Markdown: 'markdown',
    SingleSelection: 'singleSelection',
    MultipleSelections: 'multipleSelections',
    Boolean: 'boolean',
    Number: 'number',
    Datetime: 'datetime',
    Files: 'files',
    Reference: 'reference',
    Lookup: 'lookup',
    Language: 'language',
    Json: 'json',
    Yaml: 'yaml',
    Html: 'html',
    Formula: 'formula'
} as const;

export type CreateColumnTypeEnum = typeof CreateColumnTypeEnum[keyof typeof CreateColumnTypeEnum];
export const CreateColumnLanguageCodeEnum = {
    EnUs: 'enUS',
    ArSa: 'arSA',
    CaEs: 'caES',
    ZhCn: 'zhCN',
    ZhTw: 'zhTW',
    DeDe: 'deDE',
    ItIt: 'itIT',
    JaJp: 'jaJP',
    KoKr: 'koKR',
    PlPl: 'plPL',
    PtAo: 'ptAO',
    PtBr: 'ptBR',
    RuRu: 'ruRU',
    EsMx: 'esMX',
    EsLa: 'esLA',
    EsEs: 'esES',
    BnBd: 'bnBD',
    BgBg: 'bgBG',
    ZhHk: 'zhHK',
    CsCz: 'csCZ',
    DaDk: 'daDK',
    NlNl: 'nlNL',
    FiFi: 'fiFI',
    FrFr: 'frFR',
    FrCa: 'frCA',
    ElGr: 'elGR',
    HeIl: 'heIL',
    HiIn: 'hiIN',
    HuHu: 'huHU',
    IdId: 'idID',
    JwId: 'jwID',
    LvLv: 'lvLV',
    MsMy: 'msMY',
    NoNo: 'noNO',
    PtPt: 'ptPT',
    RoRo: 'roRO',
    SkSk: 'skSK',
    SvSe: 'svSE',
    TlPh: 'tlPH',
    ThTh: 'thTH',
    TrTr: 'trTR',
    UkUa: 'ukUA',
    UrIn: 'urIN',
    ViVn: 'viVN',
    AfZa: 'afZA',
    ArAe: 'arAE',
    ArBh: 'arBH',
    ArDz: 'arDZ',
    ArEg: 'arEG',
    ArIq: 'arIQ',
    ArJo: 'arJO',
    ArKw: 'arKW',
    ArLb: 'arLB',
    ArLy: 'arLY',
    ArMa: 'arMA',
    ArOm: 'arOM',
    ArQa: 'arQA',
    ArSy: 'arSY',
    ArTn: 'arTN',
    ArYe: 'arYE',
    AzAz: 'azAZ',
    BeBy: 'beBY',
    BsBa: 'bsBA',
    CyGb: 'cyGB',
    DeAt: 'deAT',
    DeCh: 'deCH',
    DeLi: 'deLI',
    DeLu: 'deLU',
    DvMv: 'dvMV',
    EnAu: 'enAU',
    EnBz: 'enBZ',
    EnCa: 'enCA',
    EnGb: 'enGB',
    EnIe: 'enIE',
    EnJm: 'enJM',
    EnNz: 'enNZ',
    EnPh: 'enPH',
    EnTt: 'enTT',
    EnZa: 'enZA',
    EnZw: 'enZW',
    EnSg: 'enSG',
    EnIn: 'enIN',
    EnGh: 'enGH',
    EnRw: 'enRW',
    EnZm: 'enZM',
    EnKe: 'enKE',
    EnNg: 'enNG',
    EsAr: 'esAR',
    EsBo: 'esBO',
    EsCl: 'esCL',
    EsCo: 'esCO',
    EsCr: 'esCR',
    EsDo: 'esDO',
    EsEc: 'esEC',
    EsGt: 'esGT',
    EsHn: 'esHN',
    EsNi: 'esNI',
    EsPa: 'esPA',
    EsPe: 'esPE',
    EsPr: 'esPR',
    EsPy: 'esPY',
    EsSv: 'esSV',
    EsUy: 'esUY',
    EsVe: 'esVE',
    EtEe: 'etEE',
    EuEs: 'euES',
    FaIr: 'faIR',
    FoFo: 'foFO',
    FrBe: 'frBE',
    FrCh: 'frCH',
    FrLu: 'frLU',
    FrMc: 'frMC',
    GlEs: 'glES',
    GuIn: 'guIN',
    HrBa: 'hrBA',
    HrHr: 'hrHR',
    HyAm: 'hyAM',
    IsIs: 'isIS',
    ItCh: 'itCH',
    KaGe: 'kaGE',
    KkKz: 'kkKZ',
    KnIn: 'knIN',
    KokIn: 'kokIN',
    KyKg: 'kyKG',
    LtLt: 'ltLT',
    MiNz: 'miNZ',
    MkMk: 'mkMK',
    MnMn: 'mnMN',
    MrIn: 'mrIN',
    MsBn: 'msBN',
    MtMt: 'mtMT',
    NbNo: 'nbNO',
    NlBe: 'nlBE',
    NnNo: 'nnNO',
    NsZa: 'nsZA',
    PaIn: 'paIN',
    PsAr: 'psAR',
    QuBo: 'quBO',
    QuEc: 'quEC',
    QuPe: 'quPE',
    SaIn: 'saIN',
    SeFi: 'seFI',
    SeNo: 'seNO',
    SeSe: 'seSE',
    SlSi: 'slSI',
    SqAl: 'sqAL',
    SrBa: 'srBA',
    SrRs: 'srRS',
    SrMe: 'srME',
    SvFi: 'svFI',
    SwKe: 'swKE',
    SyrSy: 'syrSY',
    TaIn: 'taIN',
    TeIn: 'teIN',
    TnZa: 'tnZA',
    TtRu: 'ttRU',
    UrPk: 'urPK',
    UzUz: 'uzUZ',
    XhZa: 'xhZA',
    ZhMo: 'zhMO',
    ZhSg: 'zhSG',
    ZuZa: 'zuZA',
    Am: 'am',
    Hy: 'hy',
    Az: 'az',
    Bn: 'bn',
    Bs: 'bs',
    Ca: 'ca',
    Hr: 'hr',
    Da: 'da',
    Nl: 'nl',
    En: 'en',
    Fi: 'fi',
    Fr: 'fr',
    Hi: 'hi',
    Hu: 'hu',
    Id: 'id',
    It: 'it',
    Km: 'km',
    Mi: 'mi',
    Ps: 'ps',
    Ru: 'ru',
    Sl: 'sl',
    Es: 'es',
    Sw: 'sw',
    Ta: 'ta',
    Ur: 'ur',
    Af: 'af',
    Et: 'et',
    Gl: 'gl',
    Ja: 'ja',
    Kk: 'kk',
    Ky: 'ky',
    Mk: 'mk',
    Ms: 'ms',
    Se: 'se',
    Pl: 'pl',
    Pa: 'pa',
    Ro: 'ro',
    Sk: 'sk',
    Sv: 'sv',
    Tt: 'tt',
    Te: 'te',
    Tr: 'tr',
    Uz: 'uz',
    Vi: 'vi',
    Eu: 'eu',
    Be: 'be',
    Cs: 'cs',
    De: 'de',
    Gu: 'gu',
    He: 'he',
    Is: 'is',
    Ko: 'ko',
    Lt: 'lt',
    Mr: 'mr',
    Mn: 'mn',
    Nb: 'nb',
    Nn: 'nn',
    Pt: 'pt',
    Sa: 'sa',
    Tn: 'tn',
    Uk: 'uk',
    Xh: 'xh',
    Sq: 'sq',
    Ar: 'ar',
    Bg: 'bg',
    Zh: 'zh',
    Dv: 'dv',
    Fo: 'fo',
    Fa: 'fa',
    Ka: 'ka',
    El: 'el',
    Kn: 'kn',
    Lv: 'lv',
    Mt: 'mt',
    Qu: 'qu',
    Sr: 'sr',
    Si: 'si',
    Tl: 'tl',
    Th: 'th',
    Cy: 'cy',
    Zu: 'zu',
    No: 'no'
} as const;

export type CreateColumnLanguageCodeEnum = typeof CreateColumnLanguageCodeEnum[keyof typeof CreateColumnLanguageCodeEnum];
export const CreateColumnLocalizationTypeEnum = {
    SourceLanguage: 'sourceLanguage',
    TargetLanguage: 'targetLanguage'
} as const;

export type CreateColumnLocalizationTypeEnum = typeof CreateColumnLocalizationTypeEnum[keyof typeof CreateColumnLocalizationTypeEnum];

/**
 * body
 * @export
 * @interface CreateDatabase
 */
export interface CreateDatabase {
    /**
     * 
     * @type {string}
     * @memberof CreateDatabase
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDatabase
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateDatabase
     */
    'enableGuidRecord'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateDatabase
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface CreateDependency
 */
export interface CreateDependency {
    /**
     * 
     * @type {string}
     * @memberof CreateDependency
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDependency
     */
    'targetColumnId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDependency
     */
    'sourceColumnId': string;
}
/**
 * 
 * @export
 * @interface CreateFileCategory
 */
export interface CreateFileCategory {
    /**
     * 
     * @type {string}
     * @memberof CreateFileCategory
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateGlossary
 */
export interface CreateGlossary {
    /**
     * 
     * @type {string}
     * @memberof CreateGlossary
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGlossary
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateGlossary
     */
    'langs'?: Array<string>;
    /**
     * 
     * @type {Array<GlossaryProject>}
     * @memberof CreateGlossary
     */
    'projects'?: Array<GlossaryProject>;
}
/**
 * 
 * @export
 * @interface CreateGrid
 */
export interface CreateGrid {
    /**
     * 
     * @type {string}
     * @memberof CreateGrid
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGrid
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGrid
     */
    'templateGridId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGrid
     */
    'recordIdentifierType'?: CreateGridRecordIdentifierTypeEnum;
    /**
     * 
     * @type {Array<CreateColumn>}
     * @memberof CreateGrid
     */
    'columns'?: Array<CreateColumn>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateGrid
     */
    'metadata'?: { [key: string]: string; };
}

export const CreateGridRecordIdentifierTypeEnum = {
    RecordId: 'recordId',
    PathTagRecordId: 'pathTagRecordId'
} as const;

export type CreateGridRecordIdentifierTypeEnum = typeof CreateGridRecordIdentifierTypeEnum[keyof typeof CreateGridRecordIdentifierTypeEnum];

/**
 * 
 * @export
 * @interface CreatePath
 */
export interface CreatePath {
    /**
     * 
     * @type {string}
     * @memberof CreatePath
     */
    'parentPath'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreatePath
     */
    'paths'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateProject
 */
export interface CreateProject {
    /**
     * 
     * @type {string}
     * @memberof CreateProject
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProject
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateShareView
 */
export interface CreateShareView {
    /**
     * 
     * @type {boolean}
     * @memberof CreateShareView
     */
    'includeGridHistory'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateTransMem
 */
export interface CreateTransMem {
    /**
     * 
     * @type {string}
     * @memberof CreateTransMem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransMem
     */
    'description'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateTransMem
     */
    'projectIds'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTransMem
     */
    'fuzzyMatch'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTransMem
     */
    'isDisabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTransMem
     */
    'isPausedConsuming'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTransMem
     */
    'contextLookup'?: boolean;
    /**
     * 
     * @type {TranslationStatus}
     * @memberof CreateTransMem
     */
    'populateTranslationStatus'?: TranslationStatus;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTransMem
     */
    'allowAlternative'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateView
 */
export interface CreateView {
    /**
     * 
     * @type {string}
     * @memberof CreateView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateView
     */
    'gridId'?: string;
    /**
     * 
     * @type {Array<AddViewColumn>}
     * @memberof CreateView
     */
    'columns'?: Array<AddViewColumn>;
}
/**
 * 
 * @export
 * @interface Database
 */
export interface Database {
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Database
     */
    'projectId'?: number;
    /**
     * 
     * @type {Array<Grid>}
     * @memberof Database
     */
    'grids'?: Array<Grid>;
    /**
     * 
     * @type {Array<View>}
     * @memberof Database
     */
    'views'?: Array<View>;
    /**
     * 
     * @type {Project}
     * @memberof Database
     */
    'project'?: Project;
    /**
     * 
     * @type {Set<Group>}
     * @memberof Database
     */
    'groups'?: Set<Group>;
}
/**
 * 
 * @export
 * @interface DateTimeFormat
 */
export interface DateTimeFormat {
    /**
     * 
     * @type {string}
     * @memberof DateTimeFormat
     */
    'dateFormat'?: string;
    /**
     * 
     * @type {string}
     * @memberof DateTimeFormat
     */
    'timeFormat'?: string;
    /**
     * 
     * @type {string}
     * @memberof DateTimeFormat
     */
    'zoneOffset'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DateTimeFormat
     */
    'showTimeZone'?: boolean;
}
/**
 * 
 * @export
 * @interface DeleteDependency
 */
export interface DeleteDependency {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteDependency
     */
    'ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteFile
 */
export interface DeleteFile {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteFile
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DeletePath
 */
export interface DeletePath {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeletePath
     */
    'paths'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteRecord
 */
export interface DeleteRecord {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteRecord
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {Array<RecordIdentifierWrapper>}
     * @memberof DeleteRecord
     */
    'identifiers'?: Array<RecordIdentifierWrapper>;
}
/**
 * 
 * @export
 * @interface Dependency
 */
export interface Dependency {
    /**
     * 
     * @type {string}
     * @memberof Dependency
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dependency
     */
    'sourceColumnId': string;
    /**
     * 
     * @type {string}
     * @memberof Dependency
     */
    'targetColumnId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ExportFileHeader = {
    none: 'none',
    columnName: 'columnName',
    columnId: 'columnId'
} as const;

export type ExportFileHeader = typeof ExportFileHeader[keyof typeof ExportFileHeader];


/**
 * 
 * @export
 * @enum {string}
 */

export const ExportFormat = {
    Tmx: 'tmx',
    Csv: 'csv',
    Xlsx: 'xlsx'
} as const;

export type ExportFormat = typeof ExportFormat[keyof typeof ExportFormat];


/**
 * 
 * @export
 * @enum {string}
 */

export const FetchFileOption = {
    all: 'all',
    id: 'id',
    name: 'name'
} as const;

export type FetchFileOption = typeof FetchFileOption[keyof typeof FetchFileOption];


/**
 * 
 * @export
 * @interface FetchRecordHistoryRequest
 */
export interface FetchRecordHistoryRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof FetchRecordHistoryRequest
     */
    'columnIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FetchRecordHistoryRequest
     */
    'query'?: string;
    /**
     * 
     * @type {string}
     * @memberof FetchRecordHistoryRequest
     */
    'sort'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FetchRecordHistoryRequest
     */
    'groupBy'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FetchRecordHistoryRequest
     */
    'page'?: string;
    /**
     * 
     * @type {string}
     * @memberof FetchRecordHistoryRequest
     */
    'fetchOptions'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FetchRecordHistoryRequest
     */
    'includeSystemUser'?: boolean;
}
/**
 * 
 * @export
 * @interface FileCategory
 */
export interface FileCategory {
    /**
     * 
     * @type {string}
     * @memberof FileCategory
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileCategory
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface FilterField
 */
export interface FilterField {
    /**
     * 
     * @type {boolean}
     * @memberof FilterField
     */
    'caseSensitive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FilterField
     */
    'columnId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterField
     */
    'dynamicColumn'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterField
     */
    'operator': FilterFieldOperatorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof FilterField
     */
    'queryPathTagViaId'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FilterField
     */
    'subField'?: FilterFieldSubFieldEnum;
    /**
     * 
     * @type {Array<object>}
     * @memberof FilterField
     */
    'values'?: Array<object>;
}

export const FilterFieldOperatorEnum = {
    IsNull: 'isNull',
    IsNotNull: 'isNotNull',
    IsEmpty: 'isEmpty',
    IsNotEmpty: 'isNotEmpty',
    Contains: 'contains',
    NotContains: 'notContains',
    StartsWith: 'startsWith',
    NotStartsWith: 'notStartsWith',
    EndsWith: 'endsWith',
    NotEndsWith: 'notEndsWith',
    Regexp: 'regexp',
    NotRegexp: 'notRegexp',
    Equal: '=',
    NotEqual: '!=',
    LessThan: '<',
    LessThanOrEqualTo: '<=',
    GreaterThan: '>',
    GreaterThanOrEqualTo: '>=',
    In: 'in',
    NotIn: 'notIn',
    ModifiedBy: 'modifiedBy',
    NotModifiedBy: 'notModifiedBy',
    Between: 'between',
    NotBetween: 'notBetween',
    HasQaError: 'hasQaError',
    IsLengthViolated: 'isLengthViolated',
    HasTag: 'hasTag',
    SpellCheck: 'spellCheck',
    QaCheck: 'qaCheck',
    IsMt: 'isMt'
} as const;

export type FilterFieldOperatorEnum = typeof FilterFieldOperatorEnum[keyof typeof FilterFieldOperatorEnum];
export const FilterFieldSubFieldEnum = {
    DependencyStatus: 'DEPENDENCY_STATUS',
    SourceStatus: 'SOURCE_STATUS',
    TargetStatus: 'TARGET_STATUS',
    FlowStatus: 'FLOW_STATUS',
    Tm: 'TM',
    Mt: 'MT',
    Ticket: 'TICKET',
    Color: 'COLOR',
    Metadata: 'METADATA',
    CellMetadata: 'CELL_METADATA',
    WordCount: 'WORD_COUNT',
    PreviewSourceData: 'PREVIEW_SOURCE_DATA',
    PreviewSourceDependencyStatus: 'PREVIEW_SOURCE_DEPENDENCY_STATUS',
    PreviewStatus: 'PREVIEW_STATUS',
    PreviewMergeOption: 'PREVIEW_MERGE_OPTION',
    RelativeTime: 'RELATIVE_TIME',
    LengthViolated: 'LENGTH_VIOLATED',
    LengthSetting: 'LENGTH_SETTING',
    WorkflowStatus: 'WORKFLOW_STATUS',
    Repetition: 'REPETITION',
    QaCheckStatus: 'QA_CHECK_STATUS'
} as const;

export type FilterFieldSubFieldEnum = typeof FilterFieldSubFieldEnum[keyof typeof FilterFieldSubFieldEnum];

/**
 * 
 * @export
 * @interface Formula
 */
export interface Formula {
    /**
     * 
     * @type {string}
     * @memberof Formula
     */
    'formulaText': string;
    /**
     * 
     * @type {boolean}
     * @memberof Formula
     */
    'alwaysFormatResultValueAsList'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Formula
     */
    'detectResultValueType'?: FormulaDetectResultValueTypeEnum;
}

export const FormulaDetectResultValueTypeEnum = {
    List: 'list',
    String: 'string',
    Decimal: 'decimal',
    Boolean: 'boolean',
    Datetime: 'datetime',
    Na: 'na'
} as const;

export type FormulaDetectResultValueTypeEnum = typeof FormulaDetectResultValueTypeEnum[keyof typeof FormulaDetectResultValueTypeEnum];

/**
 * 
 * @export
 * @interface Glossary
 */
export interface Glossary {
    /**
     * 
     * @type {string}
     * @memberof Glossary
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Glossary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Glossary
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Glossary
     */
    'langs'?: Array<string>;
    /**
     * 
     * @type {Array<GlossaryProject>}
     * @memberof Glossary
     */
    'projects'?: Array<GlossaryProject>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GlossaryExportFormat = {
    Csv: 'csv',
    Xls: 'xls',
    Xlsx: 'xlsx',
    Tbx: 'tbx'
} as const;

export type GlossaryExportFormat = typeof GlossaryExportFormat[keyof typeof GlossaryExportFormat];


/**
 * 
 * @export
 * @interface GlossaryProject
 */
export interface GlossaryProject {
    /**
     * 
     * @type {number}
     * @memberof GlossaryProject
     */
    'projectId'?: number;
    /**
     * 
     * @type {Set<string>}
     * @memberof GlossaryProject
     */
    'databaseIds'?: Set<string>;
}
/**
 * 
 * @export
 * @interface Grid
 */
export interface Grid {
    /**
     * 
     * @type {string}
     * @memberof Grid
     */
    'id'?: string;
    /**
     * 
     * @type {Array<ViewColumn>}
     * @memberof Grid
     */
    'columns'?: Array<ViewColumn>;
    /**
     * 
     * @type {string}
     * @memberof Grid
     */
    'defaultAccessViewId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Grid
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Grid
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Grid
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Grid
     */
    'recordIdentifierType'?: GridRecordIdentifierTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Grid
     */
    'status'?: GridStatusEnum;
}

export const GridRecordIdentifierTypeEnum = {
    RecordId: 'recordId',
    PathTagRecordId: 'pathTagRecordId'
} as const;

export type GridRecordIdentifierTypeEnum = typeof GridRecordIdentifierTypeEnum[keyof typeof GridRecordIdentifierTypeEnum];
export const GridStatusEnum = {
    Deleted: 'deleted',
    Active: 'active',
    Inactive: 'inactive',
    Restoring: 'restoring',
    BackingUp: 'backingUp',
    Uploading: 'uploading',
    Importing: 'importing',
    Branching: 'branching',
    Merging: 'merging',
    Duplicating: 'duplicating',
    ClearingRecords: 'clearingRecords',
    Copying: 'copying'
} as const;

export type GridStatusEnum = typeof GridStatusEnum[keyof typeof GridStatusEnum];

/**
 * 
 * @export
 * @interface GridSetting
 */
export interface GridSetting {
    /**
     * 
     * @type {string}
     * @memberof GridSetting
     */
    'defaultSourceLanguageStatus'?: GridSettingDefaultSourceLanguageStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GridSetting
     */
    'translatorCanViewAutomations'?: boolean;
    /**
     * 
     * @type {Array<FileCategory>}
     * @memberof GridSetting
     */
    'categories'?: Array<FileCategory>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GridSetting
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof GridSetting
     */
    'createdTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof GridSetting
     */
    'lastModifiedTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof GridSetting
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof GridSetting
     */
    'lastModifiedBy'?: string;
}

export const GridSettingDefaultSourceLanguageStatusEnum = {
    Unset: 'unset',
    DoNotTranslate: 'doNotTranslate',
    NotReadyForTranslation: 'notReadyForTranslation',
    ReadyForTranslation: 'readyForTranslation',
    Locked: 'locked',
    LockAllLanguages: 'lockAllLanguages'
} as const;

export type GridSettingDefaultSourceLanguageStatusEnum = typeof GridSettingDefaultSourceLanguageStatusEnum[keyof typeof GridSettingDefaultSourceLanguageStatusEnum];

/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'groupId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'companyId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'logoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'type'?: GroupTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'shareType'?: GroupShareTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'isSystemGroup'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'systemGroup'?: boolean;
}

export const GroupTypeEnum = {
    Normal: 'NORMAL',
    Admin: 'ADMIN'
} as const;

export type GroupTypeEnum = typeof GroupTypeEnum[keyof typeof GroupTypeEnum];
export const GroupShareTypeEnum = {
    None: 'none',
    Full: 'full',
    Project: 'project',
    Database: 'database',
    Grid: 'grid',
    View: 'view'
} as const;

export type GroupShareTypeEnum = typeof GroupShareTypeEnum[keyof typeof GroupShareTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const ImportOption = {
    Add: 'ADD',
    Update: 'UPDATE',
    UpdateOnly: 'UPDATE_ONLY'
} as const;

export type ImportOption = typeof ImportOption[keyof typeof ImportOption];


/**
 * 
 * @export
 * @interface MergeBranchRequest
 */
export interface MergeBranchRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof MergeBranchRequest
     */
    'mergeRecordOptions'?: Array<MergeBranchRequestMergeRecordOptionsEnum>;
    /**
     * 
     * @type {Array<MergeRecordConflict>}
     * @memberof MergeBranchRequest
     */
    'mergeRecordConflicts'?: Array<MergeRecordConflict>;
    /**
     * 
     * @type {boolean}
     * @memberof MergeBranchRequest
     */
    'useLastMergeResolve'?: boolean;
    /**
     * 
     * @type {Array<FilterField>}
     * @memberof MergeBranchRequest
     */
    'query'?: Array<FilterField>;
}

export const MergeBranchRequestMergeRecordOptionsEnum = {
    Add: 'add',
    Update: 'update',
    Delete: 'delete',
    Override: 'override'
} as const;

export type MergeBranchRequestMergeRecordOptionsEnum = typeof MergeBranchRequestMergeRecordOptionsEnum[keyof typeof MergeBranchRequestMergeRecordOptionsEnum];

/**
 * 
 * @export
 * @interface MergeCellConflict
 */
export interface MergeCellConflict {
    /**
     * 
     * @type {string}
     * @memberof MergeCellConflict
     */
    'columnId': string;
    /**
     * 
     * @type {string}
     * @memberof MergeCellConflict
     */
    'option': MergeCellConflictOptionEnum;
}

export const MergeCellConflictOptionEnum = {
    Child: 'child',
    Parent: 'parent',
    Override: 'override',
    OverrideUpToDate: 'overrideUpToDate',
    OverrideOutOfDate: 'overrideOutOfDate',
    Reserve: 'reserve',
    Ignore: 'ignore',
    Source: 'source',
    Destination: 'destination'
} as const;

export type MergeCellConflictOptionEnum = typeof MergeCellConflictOptionEnum[keyof typeof MergeCellConflictOptionEnum];

/**
 * 
 * @export
 * @interface MergeRecordConflict
 */
export interface MergeRecordConflict {
    /**
     * 
     * @type {Array<MergeCellConflict>}
     * @memberof MergeRecordConflict
     */
    'cells'?: Array<MergeCellConflict>;
    /**
     * 
     * @type {string}
     * @memberof MergeRecordConflict
     */
    'pathTag'?: string;
    /**
     * 
     * @type {string}
     * @memberof MergeRecordConflict
     */
    'recordId'?: string;
}
/**
 * 
 * @export
 * @interface MovePath
 */
export interface MovePath {
    /**
     * 
     * @type {Array<string>}
     * @memberof MovePath
     */
    'names'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MovePath
     */
    'fromParentPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof MovePath
     */
    'toParentPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof MovePath
     */
    'moveBefore'?: string;
    /**
     * 
     * @type {string}
     * @memberof MovePath
     */
    'moveAfter'?: string;
}
/**
 * 
 * @export
 * @interface NumberFormat
 */
export interface NumberFormat {
    /**
     * 
     * @type {string}
     * @memberof NumberFormat
     */
    'type'?: NumberFormatTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof NumberFormat
     */
    'decimalPlaces'?: number;
    /**
     * 
     * @type {string}
     * @memberof NumberFormat
     */
    'currencySymbol'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NumberFormat
     */
    'use1000Separator'?: boolean;
}

export const NumberFormatTypeEnum = {
    Decimal: 'DECIMAL',
    Integer: 'INTEGER'
} as const;

export type NumberFormatTypeEnum = typeof NumberFormatTypeEnum[keyof typeof NumberFormatTypeEnum];

/**
 * 
 * @export
 * @interface PathList
 */
export interface PathList {
    /**
     * 
     * @type {Array<string>}
     * @memberof PathList
     */
    'paths'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PathNode
 */
export interface PathNode {
    /**
     * 
     * @type {string}
     * @memberof PathNode
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PathNode
     */
    'parentPath'?: string;
}
/**
 * 
 * @export
 * @interface PathSingle
 */
export interface PathSingle {
    /**
     * 
     * @type {string}
     * @memberof PathSingle
     */
    'path'?: string;
}
/**
 * 
 * @export
 * @interface Privilege
 */
export interface Privilege {
    /**
     * 
     * @type {number}
     * @memberof Privilege
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Privilege
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Privilege
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof Privilege
     */
    'level'?: string;
    /**
     * 
     * @type {number}
     * @memberof Privilege
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof Privilege
     */
    'serviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Privilege
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Privilege
     */
    'extra'?: string;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'companyId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'description'?: string;
    /**
     * 
     * @type {Role}
     * @memberof Project
     */
    'role'?: Role;
}
/**
 * 
 * @export
 * @interface ProjectDetail
 */
export interface ProjectDetail {
    /**
     * 
     * @type {number}
     * @memberof ProjectDetail
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectDetail
     */
    'companyId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectDetail
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDetail
     */
    'description'?: string;
    /**
     * 
     * @type {Role}
     * @memberof ProjectDetail
     */
    'role'?: Role;
    /**
     * 
     * @type {Array<Database>}
     * @memberof ProjectDetail
     */
    'databases'?: Array<Database>;
    /**
     * 
     * @type {Array<Group>}
     * @memberof ProjectDetail
     */
    'groups'?: Array<Group>;
}
/**
 * 
 * @export
 * @interface Record
 */
export interface Record {
    /**
     * 
     * @type {string}
     * @memberof Record
     */
    'id'?: string;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof Record
     */
    'cells'?: Array<Cell>;
    /**
     * 
     * @type {string}
     * @memberof Record
     */
    'lastModifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Record
     */
    'lastModifiedTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Record
     */
    'path'?: string;
}
/**
 * 
 * @export
 * @interface RecordHistory
 */
export interface RecordHistory {
    /**
     * 
     * @type {string}
     * @memberof RecordHistory
     */
    'path'?: string;
    /**
     * 
     * @type {Array<CellHistory>}
     * @memberof RecordHistory
     */
    'cells'?: Array<CellHistory>;
    /**
     * 
     * @type {string}
     * @memberof RecordHistory
     */
    'lastModifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecordHistory
     */
    'lastModifiedTime'?: string;
}
/**
 * 
 * @export
 * @interface RecordIdentifierWrapper
 */
export interface RecordIdentifierWrapper {
    /**
     * 
     * @type {string}
     * @memberof RecordIdentifierWrapper
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RecordIdentifierWrapper
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface Reference
 */
export interface Reference {
    /**
     * 
     * @type {string}
     * @memberof Reference
     */
    'gridId': string;
    /**
     * 
     * @type {string}
     * @memberof Reference
     */
    'branchId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Reference
     */
    'columnId': string;
    /**
     * 
     * @type {string}
     * @memberof Reference
     */
    'type'?: ReferenceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Reference
     */
    'selectionType'?: ReferenceSelectionTypeEnum;
}

export const ReferenceTypeEnum = {
    Row: 'ROW',
    Cell: 'CELL'
} as const;

export type ReferenceTypeEnum = typeof ReferenceTypeEnum[keyof typeof ReferenceTypeEnum];
export const ReferenceSelectionTypeEnum = {
    Single: 'SINGLE',
    Multiple: 'MULTIPLE'
} as const;

export type ReferenceSelectionTypeEnum = typeof ReferenceSelectionTypeEnum[keyof typeof ReferenceSelectionTypeEnum];

/**
 * 
 * @export
 * @interface ReferencedColumn
 */
export interface ReferencedColumn {
    /**
     * 
     * @type {string}
     * @memberof ReferencedColumn
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReferencedColumn
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ReferencedColumn
     */
    'selectionOptions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ReferencedGrid
 */
export interface ReferencedGrid {
    /**
     * 
     * @type {string}
     * @memberof ReferencedGrid
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReferencedGrid
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'level'?: string;
    /**
     * 
     * @type {Set<Privilege>}
     * @memberof Role
     */
    'privileges'?: Set<Privilege>;
    /**
     * 
     * @type {Set<number>}
     * @memberof Role
     */
    'privilegeIds'?: Set<number>;
    /**
     * 
     * @type {boolean}
     * @memberof Role
     */
    'isSystemRole'?: boolean;
}
/**
 * 
 * @export
 * @interface SetCell
 */
export interface SetCell {
    /**
     * 
     * @type {string}
     * @memberof SetCell
     */
    'columnId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SetCell
     */
    'dependencyStatus'?: SetCellDependencyStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof SetCell
     */
    'lengthLimit'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof SetCell
     */
    'referencedIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SetCell
     */
    'sourceStatus'?: SetCellSourceStatusEnum;
    /**
     * 
     * @type {any}
     * @memberof SetCell
     */
    'value'?: any;
}

export const SetCellDependencyStatusEnum = {
    UpToDate: 'upToDate',
    OutOfDate: 'outOfDate',
    Unset: 'unset'
} as const;

export type SetCellDependencyStatusEnum = typeof SetCellDependencyStatusEnum[keyof typeof SetCellDependencyStatusEnum];
export const SetCellSourceStatusEnum = {
    Unset: 'unset',
    DoNotTranslate: 'doNotTranslate',
    NotReadyForTranslation: 'notReadyForTranslation',
    ReadyForTranslation: 'readyForTranslation',
    Locked: 'locked',
    LockAllLanguages: 'lockAllLanguages'
} as const;

export type SetCellSourceStatusEnum = typeof SetCellSourceStatusEnum[keyof typeof SetCellSourceStatusEnum];

/**
 * 
 * @export
 * @interface SetRecord
 */
export interface SetRecord {
    /**
     * 
     * @type {string}
     * @memberof SetRecord
     */
    'id'?: string;
    /**
     * 
     * @type {Array<SetCell>}
     * @memberof SetRecord
     */
    'cells'?: Array<SetCell>;
    /**
     * 
     * @type {string}
     * @memberof SetRecord
     */
    'path'?: string;
}
/**
 * 
 * @export
 * @interface SettingFile
 */
export interface SettingFile {
    /**
     * 
     * @type {FileCategory}
     * @memberof SettingFile
     */
    'category'?: FileCategory;
    /**
     * 
     * @type {Array<UploadedFile>}
     * @memberof SettingFile
     */
    'files'?: Array<UploadedFile>;
}
/**
 * 
 * @export
 * @interface ShareView
 */
export interface ShareView {
    /**
     * 
     * @type {string}
     * @memberof ShareView
     */
    'companyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShareView
     */
    'link'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShareView
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShareView
     */
    'viewId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShareView
     */
    'includeGridHistory'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShareView
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShareView
     */
    'lastModifiedDate'?: string;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'status'?: TaskStatusEnum;
}

export const TaskStatusEnum = {
    Failed: 'failed',
    Successful: 'successful',
    Running: 'running',
    RetrySuccessful: 'retrySuccessful',
    Cancel: 'cancel'
} as const;

export type TaskStatusEnum = typeof TaskStatusEnum[keyof typeof TaskStatusEnum];

/**
 * 
 * @export
 * @interface TransMem
 */
export interface TransMem {
    /**
     * 
     * @type {string}
     * @memberof TransMem
     */
    'id'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof TransMem
     */
    'projectIds'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof TransMem
     */
    'isDisabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransMem
     */
    'isPausedConsuming'?: boolean;
    /**
     * 
     * @type {TranslationStatus}
     * @memberof TransMem
     */
    'populateTranslationStatus'?: TranslationStatus;
    /**
     * 
     * @type {boolean}
     * @memberof TransMem
     */
    'contextLookup'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TransMem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TransMem
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransMem
     */
    'fuzzyMatch'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransMem
     */
    'allowAlternative'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransMem
     */
    'allowAlternativeHasSameRecordId'?: boolean;
}
/**
 * 
 * @export
 * @interface TranslationCount
 */
export interface TranslationCount {
    /**
     * 
     * @type {number}
     * @memberof TranslationCount
     */
    'all'?: number;
    /**
     * 
     * @type {number}
     * @memberof TranslationCount
     */
    'outOfDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof TranslationCount
     */
    'unset'?: number;
    /**
     * 
     * @type {number}
     * @memberof TranslationCount
     */
    'upToDate'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TranslationStatus = {
    UpToDate: 'upToDate',
    OutOfDate: 'outOfDate',
    Unset: 'unset'
} as const;

export type TranslationStatus = typeof TranslationStatus[keyof typeof TranslationStatus];


/**
 * 
 * @export
 * @interface UpdateCategory
 */
export interface UpdateCategory {
    /**
     * 
     * @type {string}
     * @memberof UpdateCategory
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateColumn
 */
export interface UpdateColumn {
    /**
     * 
     * @type {string}
     * @memberof UpdateColumn
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateColumn
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateColumn
     */
    'type'?: UpdateColumnTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateColumn
     */
    'languageCode'?: UpdateColumnLanguageCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateColumn
     */
    'localizationType'?: UpdateColumnLocalizationTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateColumn
     */
    'selectionOptions'?: Array<string>;
    /**
     * 
     * @type {NumberFormat}
     * @memberof UpdateColumn
     */
    'numberFormat'?: NumberFormat;
    /**
     * 
     * @type {Reference}
     * @memberof UpdateColumn
     */
    'reference'?: Reference;
    /**
     * 
     * @type {Formula}
     * @memberof UpdateColumn
     */
    'formula'?: Formula;
    /**
     * 
     * @type {DateTimeFormat}
     * @memberof UpdateColumn
     */
    'dateTimeFormat'?: DateTimeFormat;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateColumn
     */
    'viewable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateColumn
     */
    'editable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateColumn
     */
    'newId'?: string;
}

export const UpdateColumnTypeEnum = {
    SingleLine: 'singleLine',
    MultipleLines: 'multipleLines',
    RichText: 'richText',
    Markdown: 'markdown',
    SingleSelection: 'singleSelection',
    MultipleSelections: 'multipleSelections',
    Boolean: 'boolean',
    Number: 'number',
    Datetime: 'datetime',
    Files: 'files',
    Reference: 'reference',
    Lookup: 'lookup',
    Language: 'language',
    Json: 'json',
    Yaml: 'yaml',
    Html: 'html',
    Formula: 'formula'
} as const;

export type UpdateColumnTypeEnum = typeof UpdateColumnTypeEnum[keyof typeof UpdateColumnTypeEnum];
export const UpdateColumnLanguageCodeEnum = {
    EnUs: 'enUS',
    ArSa: 'arSA',
    CaEs: 'caES',
    ZhCn: 'zhCN',
    ZhTw: 'zhTW',
    DeDe: 'deDE',
    ItIt: 'itIT',
    JaJp: 'jaJP',
    KoKr: 'koKR',
    PlPl: 'plPL',
    PtAo: 'ptAO',
    PtBr: 'ptBR',
    RuRu: 'ruRU',
    EsMx: 'esMX',
    EsLa: 'esLA',
    EsEs: 'esES',
    BnBd: 'bnBD',
    BgBg: 'bgBG',
    ZhHk: 'zhHK',
    CsCz: 'csCZ',
    DaDk: 'daDK',
    NlNl: 'nlNL',
    FiFi: 'fiFI',
    FrFr: 'frFR',
    FrCa: 'frCA',
    ElGr: 'elGR',
    HeIl: 'heIL',
    HiIn: 'hiIN',
    HuHu: 'huHU',
    IdId: 'idID',
    JwId: 'jwID',
    LvLv: 'lvLV',
    MsMy: 'msMY',
    NoNo: 'noNO',
    PtPt: 'ptPT',
    RoRo: 'roRO',
    SkSk: 'skSK',
    SvSe: 'svSE',
    TlPh: 'tlPH',
    ThTh: 'thTH',
    TrTr: 'trTR',
    UkUa: 'ukUA',
    UrIn: 'urIN',
    ViVn: 'viVN',
    AfZa: 'afZA',
    ArAe: 'arAE',
    ArBh: 'arBH',
    ArDz: 'arDZ',
    ArEg: 'arEG',
    ArIq: 'arIQ',
    ArJo: 'arJO',
    ArKw: 'arKW',
    ArLb: 'arLB',
    ArLy: 'arLY',
    ArMa: 'arMA',
    ArOm: 'arOM',
    ArQa: 'arQA',
    ArSy: 'arSY',
    ArTn: 'arTN',
    ArYe: 'arYE',
    AzAz: 'azAZ',
    BeBy: 'beBY',
    BsBa: 'bsBA',
    CyGb: 'cyGB',
    DeAt: 'deAT',
    DeCh: 'deCH',
    DeLi: 'deLI',
    DeLu: 'deLU',
    DvMv: 'dvMV',
    EnAu: 'enAU',
    EnBz: 'enBZ',
    EnCa: 'enCA',
    EnGb: 'enGB',
    EnIe: 'enIE',
    EnJm: 'enJM',
    EnNz: 'enNZ',
    EnPh: 'enPH',
    EnTt: 'enTT',
    EnZa: 'enZA',
    EnZw: 'enZW',
    EnSg: 'enSG',
    EnIn: 'enIN',
    EnGh: 'enGH',
    EnRw: 'enRW',
    EnZm: 'enZM',
    EnKe: 'enKE',
    EnNg: 'enNG',
    EsAr: 'esAR',
    EsBo: 'esBO',
    EsCl: 'esCL',
    EsCo: 'esCO',
    EsCr: 'esCR',
    EsDo: 'esDO',
    EsEc: 'esEC',
    EsGt: 'esGT',
    EsHn: 'esHN',
    EsNi: 'esNI',
    EsPa: 'esPA',
    EsPe: 'esPE',
    EsPr: 'esPR',
    EsPy: 'esPY',
    EsSv: 'esSV',
    EsUy: 'esUY',
    EsVe: 'esVE',
    EtEe: 'etEE',
    EuEs: 'euES',
    FaIr: 'faIR',
    FoFo: 'foFO',
    FrBe: 'frBE',
    FrCh: 'frCH',
    FrLu: 'frLU',
    FrMc: 'frMC',
    GlEs: 'glES',
    GuIn: 'guIN',
    HrBa: 'hrBA',
    HrHr: 'hrHR',
    HyAm: 'hyAM',
    IsIs: 'isIS',
    ItCh: 'itCH',
    KaGe: 'kaGE',
    KkKz: 'kkKZ',
    KnIn: 'knIN',
    KokIn: 'kokIN',
    KyKg: 'kyKG',
    LtLt: 'ltLT',
    MiNz: 'miNZ',
    MkMk: 'mkMK',
    MnMn: 'mnMN',
    MrIn: 'mrIN',
    MsBn: 'msBN',
    MtMt: 'mtMT',
    NbNo: 'nbNO',
    NlBe: 'nlBE',
    NnNo: 'nnNO',
    NsZa: 'nsZA',
    PaIn: 'paIN',
    PsAr: 'psAR',
    QuBo: 'quBO',
    QuEc: 'quEC',
    QuPe: 'quPE',
    SaIn: 'saIN',
    SeFi: 'seFI',
    SeNo: 'seNO',
    SeSe: 'seSE',
    SlSi: 'slSI',
    SqAl: 'sqAL',
    SrBa: 'srBA',
    SrRs: 'srRS',
    SrMe: 'srME',
    SvFi: 'svFI',
    SwKe: 'swKE',
    SyrSy: 'syrSY',
    TaIn: 'taIN',
    TeIn: 'teIN',
    TnZa: 'tnZA',
    TtRu: 'ttRU',
    UrPk: 'urPK',
    UzUz: 'uzUZ',
    XhZa: 'xhZA',
    ZhMo: 'zhMO',
    ZhSg: 'zhSG',
    ZuZa: 'zuZA',
    Am: 'am',
    Hy: 'hy',
    Az: 'az',
    Bn: 'bn',
    Bs: 'bs',
    Ca: 'ca',
    Hr: 'hr',
    Da: 'da',
    Nl: 'nl',
    En: 'en',
    Fi: 'fi',
    Fr: 'fr',
    Hi: 'hi',
    Hu: 'hu',
    Id: 'id',
    It: 'it',
    Km: 'km',
    Mi: 'mi',
    Ps: 'ps',
    Ru: 'ru',
    Sl: 'sl',
    Es: 'es',
    Sw: 'sw',
    Ta: 'ta',
    Ur: 'ur',
    Af: 'af',
    Et: 'et',
    Gl: 'gl',
    Ja: 'ja',
    Kk: 'kk',
    Ky: 'ky',
    Mk: 'mk',
    Ms: 'ms',
    Se: 'se',
    Pl: 'pl',
    Pa: 'pa',
    Ro: 'ro',
    Sk: 'sk',
    Sv: 'sv',
    Tt: 'tt',
    Te: 'te',
    Tr: 'tr',
    Uz: 'uz',
    Vi: 'vi',
    Eu: 'eu',
    Be: 'be',
    Cs: 'cs',
    De: 'de',
    Gu: 'gu',
    He: 'he',
    Is: 'is',
    Ko: 'ko',
    Lt: 'lt',
    Mr: 'mr',
    Mn: 'mn',
    Nb: 'nb',
    Nn: 'nn',
    Pt: 'pt',
    Sa: 'sa',
    Tn: 'tn',
    Uk: 'uk',
    Xh: 'xh',
    Sq: 'sq',
    Ar: 'ar',
    Bg: 'bg',
    Zh: 'zh',
    Dv: 'dv',
    Fo: 'fo',
    Fa: 'fa',
    Ka: 'ka',
    El: 'el',
    Kn: 'kn',
    Lv: 'lv',
    Mt: 'mt',
    Qu: 'qu',
    Sr: 'sr',
    Si: 'si',
    Tl: 'tl',
    Th: 'th',
    Cy: 'cy',
    Zu: 'zu',
    No: 'no'
} as const;

export type UpdateColumnLanguageCodeEnum = typeof UpdateColumnLanguageCodeEnum[keyof typeof UpdateColumnLanguageCodeEnum];
export const UpdateColumnLocalizationTypeEnum = {
    SourceLanguage: 'sourceLanguage',
    TargetLanguage: 'targetLanguage'
} as const;

export type UpdateColumnLocalizationTypeEnum = typeof UpdateColumnLocalizationTypeEnum[keyof typeof UpdateColumnLocalizationTypeEnum];

/**
 * 
 * @export
 * @interface UpdateDatabase
 */
export interface UpdateDatabase {
    /**
     * 
     * @type {string}
     * @memberof UpdateDatabase
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDatabase
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateDependency
 */
export interface UpdateDependency {
    /**
     * 
     * @type {string}
     * @memberof UpdateDependency
     */
    'newId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDependency
     */
    'targetColumnId': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDependency
     */
    'sourceColumnId': string;
}
/**
 * 
 * @export
 * @interface UpdateGlossary
 */
export interface UpdateGlossary {
    /**
     * 
     * @type {string}
     * @memberof UpdateGlossary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGlossary
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateGlossary
     */
    'langs'?: Array<string>;
    /**
     * 
     * @type {Array<GlossaryProject>}
     * @memberof UpdateGlossary
     */
    'projects'?: Array<GlossaryProject>;
}
/**
 * 
 * @export
 * @interface UpdateGrid
 */
export interface UpdateGrid {
    /**
     * 
     * @type {string}
     * @memberof UpdateGrid
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateGrid
     */
    'metadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface UpdateGridSetting
 */
export interface UpdateGridSetting {
    /**
     * 
     * @type {DateTimeFormat}
     * @memberof UpdateGridSetting
     */
    'defaultDateTimeFormat'?: DateTimeFormat;
    /**
     * 
     * @type {string}
     * @memberof UpdateGridSetting
     */
    'defaultSourceLanguageStatus'?: UpdateGridSettingDefaultSourceLanguageStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateGridSetting
     */
    'translatorCanViewAutomations'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateGridSetting
     */
    'metadata'?: { [key: string]: string; };
}

export const UpdateGridSettingDefaultSourceLanguageStatusEnum = {
    Unset: 'unset',
    DoNotTranslate: 'doNotTranslate',
    NotReadyForTranslation: 'notReadyForTranslation',
    ReadyForTranslation: 'readyForTranslation',
    Locked: 'locked',
    LockAllLanguages: 'lockAllLanguages'
} as const;

export type UpdateGridSettingDefaultSourceLanguageStatusEnum = typeof UpdateGridSettingDefaultSourceLanguageStatusEnum[keyof typeof UpdateGridSettingDefaultSourceLanguageStatusEnum];

/**
 * 
 * @export
 * @interface UpdatePath
 */
export interface UpdatePath {
    /**
     * 
     * @type {string}
     * @memberof UpdatePath
     */
    'newName': string;
}
/**
 * 
 * @export
 * @interface UpdateProject
 */
export interface UpdateProject {
    /**
     * 
     * @type {string}
     * @memberof UpdateProject
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProject
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTransMem
 */
export interface UpdateTransMem {
    /**
     * 
     * @type {string}
     * @memberof UpdateTransMem
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTransMem
     */
    'description'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateTransMem
     */
    'projectIds'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTransMem
     */
    'fuzzyMatch'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTransMem
     */
    'isDisabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTransMem
     */
    'isPausedConsuming'?: boolean;
    /**
     * 
     * @type {TranslationStatus}
     * @memberof UpdateTransMem
     */
    'populateTranslationStatus'?: TranslationStatus;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTransMem
     */
    'contextLookup'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTransMem
     */
    'allowAlternative'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTransMem
     */
    'allowAlternativeHasSameRecordId'?: boolean;
}
/**
 * 
 * @export
 * @interface UploadSettingFileRequest
 */
export interface UploadSettingFileRequest {
    /**
     * 
     * @type {File}
     * @memberof UploadSettingFileRequest
     */
    'file'?: File;
}
/**
 * 
 * @export
 * @interface UploadZipRequest
 */
export interface UploadZipRequest {
    /**
     * 
     * @type {string}
     * @memberof UploadZipRequest
     */
    'columnId': string;
    /**
     * 
     * @type {string}
     * @memberof UploadZipRequest
     */
    'fileMappings': string;
    /**
     * 
     * @type {File}
     * @memberof UploadZipRequest
     */
    'file': File;
}
/**
 * 
 * @export
 * @interface UploadedFile
 */
export interface UploadedFile {
    /**
     * 
     * @type {string}
     * @memberof UploadedFile
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadedFile
     */
    'originalName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadedFile
     */
    'contentType'?: string;
    /**
     * 
     * @type {number}
     * @memberof UploadedFile
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof UploadedFile
     */
    'thumbnailId'?: string;
}
/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'id'?: string;
    /**
     * 
     * @type {Array<ViewColumn>}
     * @memberof View
     */
    'columns'?: Array<ViewColumn>;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'gridId'?: string;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'gridStatus'?: ViewGridStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Record>}
     * @memberof View
     */
    'records'?: Array<Record>;
}

export const ViewGridStatusEnum = {
    Deleted: 'deleted',
    Active: 'active',
    Inactive: 'inactive',
    Restoring: 'restoring',
    BackingUp: 'backingUp',
    Uploading: 'uploading',
    Importing: 'importing',
    Branching: 'branching',
    Merging: 'merging',
    Duplicating: 'duplicating',
    ClearingRecords: 'clearingRecords',
    Copying: 'copying'
} as const;

export type ViewGridStatusEnum = typeof ViewGridStatusEnum[keyof typeof ViewGridStatusEnum];

/**
 * 
 * @export
 * @interface ViewColumn
 */
export interface ViewColumn {
    /**
     * 
     * @type {string}
     * @memberof ViewColumn
     */
    'id'?: string;
    /**
     * 
     * @type {DateTimeFormat}
     * @memberof ViewColumn
     */
    'dateTimeFormat'?: DateTimeFormat;
    /**
     * 
     * @type {string}
     * @memberof ViewColumn
     */
    'dependsOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewColumn
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ViewColumn
     */
    'editable'?: boolean;
    /**
     * 
     * @type {Formula}
     * @memberof ViewColumn
     */
    'formula'?: Formula;
    /**
     * 
     * @type {boolean}
     * @memberof ViewColumn
     */
    'isSource'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ViewColumn
     */
    'isTarget'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ViewColumn
     */
    'languageCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewColumn
     */
    'localizationType'?: ViewColumnLocalizationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ViewColumn
     */
    'name'?: string;
    /**
     * 
     * @type {NumberFormat}
     * @memberof ViewColumn
     */
    'numberFormat'?: NumberFormat;
    /**
     * 
     * @type {ColumnReference}
     * @memberof ViewColumn
     */
    'reference'?: ColumnReference;
    /**
     * 
     * @type {Array<string>}
     * @memberof ViewColumn
     */
    'selectionOptions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ViewColumn
     */
    'type'?: ViewColumnTypeEnum;
}

export const ViewColumnLocalizationTypeEnum = {
    SourceLanguage: 'sourceLanguage',
    TargetLanguage: 'targetLanguage'
} as const;

export type ViewColumnLocalizationTypeEnum = typeof ViewColumnLocalizationTypeEnum[keyof typeof ViewColumnLocalizationTypeEnum];
export const ViewColumnTypeEnum = {
    SingleLine: 'singleLine',
    MultipleLines: 'multipleLines',
    RichText: 'richText',
    Markdown: 'markdown',
    SingleSelection: 'singleSelection',
    MultipleSelections: 'multipleSelections',
    Boolean: 'boolean',
    Number: 'number',
    Datetime: 'datetime',
    Files: 'files',
    Reference: 'reference',
    Lookup: 'lookup',
    Language: 'language',
    Json: 'json',
    Yaml: 'yaml',
    Html: 'html',
    Formula: 'formula'
} as const;

export type ViewColumnTypeEnum = typeof ViewColumnTypeEnum[keyof typeof ViewColumnTypeEnum];

/**
 * 
 * @export
 * @interface ViewStatistic
 */
export interface ViewStatistic {
    /**
     * 
     * @type {number}
     * @memberof ViewStatistic
     */
    'recordCount'?: number;
    /**
     * 
     * @type {{ [key: string]: ColumnStatistic; }}
     * @memberof ViewStatistic
     */
    'translations'?: { [key: string]: ColumnStatistic; };
}

/**
 * BranchApi - axios parameter creator
 * @export
 */
export const BranchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete
         * @summary delete
         * @param {string} branchId branchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (branchId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branchId' is not null or undefined
            assertParamExists('_delete', 'branchId', branchId)
            const localVarPath = `/v1/branches/{branchId}`
                .replace(`{${"branchId"}}`, encodeURIComponent(String(branchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create
         * @summary create
         * @param {CreateBranch} createBranch 
         * @param {string} [gridId] gridId
         * @param {string} [branchId] branchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createBranch: CreateBranch, gridId?: string, branchId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBranch' is not null or undefined
            assertParamExists('create', 'createBranch', createBranch)
            const localVarPath = `/v1/branches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (gridId !== undefined) {
                localVarQueryParameter['gridId'] = gridId;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branchId'] = branchId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBranch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * createDiffCheck
         * @summary createDiffCheck
         * @param {string} sourceViewId sourceViewId
         * @param {string} destinationViewId destinationViewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiffCheck: async (sourceViewId: string, destinationViewId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceViewId' is not null or undefined
            assertParamExists('createDiffCheck', 'sourceViewId', sourceViewId)
            // verify required parameter 'destinationViewId' is not null or undefined
            assertParamExists('createDiffCheck', 'destinationViewId', destinationViewId)
            const localVarPath = `/v1/branches/diffcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (sourceViewId !== undefined) {
                localVarQueryParameter['sourceViewId'] = sourceViewId;
            }

            if (destinationViewId !== undefined) {
                localVarQueryParameter['destinationViewId'] = destinationViewId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get
         * @summary get
         * @param {string} branchId branchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (branchId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branchId' is not null or undefined
            assertParamExists('get', 'branchId', branchId)
            const localVarPath = `/v1/branches/{branchId}`
                .replace(`{${"branchId"}}`, encodeURIComponent(String(branchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * getDiffCheck
         * @summary getDiffCheck
         * @param {string} taskId taskId
         * @param {Array<'add' | 'update' | 'delete' | 'override'>} [mergeRecordOptions] mergeRecordOptions
         * @param {string} [query] query
         * @param {string} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiffCheck: async (taskId: string, mergeRecordOptions?: Array<'add' | 'update' | 'delete' | 'override'>, query?: string, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getDiffCheck', 'taskId', taskId)
            const localVarPath = `/v1/branches/diffcheck/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (mergeRecordOptions) {
                localVarQueryParameter['mergeRecordOptions'] = mergeRecordOptions;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list
         * @summary list
         * @param {string} gridId gridId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (gridId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gridId' is not null or undefined
            assertParamExists('list', 'gridId', gridId)
            const localVarPath = `/v1/branches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (gridId !== undefined) {
                localVarQueryParameter['gridId'] = gridId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * merge
         * @summary merge
         * @param {string} branchId branchId
         * @param {string} destinationBranchId destinationBranchId
         * @param {MergeBranchRequest} mergeBranchRequest 
         * @param {Array<'add' | 'update' | 'delete' | 'override'>} [mergeRecordOptions] mergeRecordOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        merge: async (branchId: string, destinationBranchId: string, mergeBranchRequest: MergeBranchRequest, mergeRecordOptions?: Array<'add' | 'update' | 'delete' | 'override'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branchId' is not null or undefined
            assertParamExists('merge', 'branchId', branchId)
            // verify required parameter 'destinationBranchId' is not null or undefined
            assertParamExists('merge', 'destinationBranchId', destinationBranchId)
            // verify required parameter 'mergeBranchRequest' is not null or undefined
            assertParamExists('merge', 'mergeBranchRequest', mergeBranchRequest)
            const localVarPath = `/v1/branches/{branchId}/merge`
                .replace(`{${"branchId"}}`, encodeURIComponent(String(branchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (destinationBranchId !== undefined) {
                localVarQueryParameter['destinationBranchId'] = destinationBranchId;
            }

            if (mergeRecordOptions) {
                localVarQueryParameter['mergeRecordOptions'] = mergeRecordOptions;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mergeBranchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BranchApi - functional programming interface
 * @export
 */
export const BranchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BranchApiAxiosParamCreator(configuration)
    return {
        /**
         * delete
         * @summary delete
         * @param {string} branchId branchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(branchId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(branchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create
         * @summary create
         * @param {CreateBranch} createBranch 
         * @param {string} [gridId] gridId
         * @param {string} [branchId] branchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createBranch: CreateBranch, gridId?: string, branchId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(createBranch, gridId, branchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * createDiffCheck
         * @summary createDiffCheck
         * @param {string} sourceViewId sourceViewId
         * @param {string} destinationViewId destinationViewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiffCheck(sourceViewId: string, destinationViewId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiffCheck(sourceViewId, destinationViewId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get
         * @summary get
         * @param {string} branchId branchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(branchId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(branchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * getDiffCheck
         * @summary getDiffCheck
         * @param {string} taskId taskId
         * @param {Array<'add' | 'update' | 'delete' | 'override'>} [mergeRecordOptions] mergeRecordOptions
         * @param {string} [query] query
         * @param {string} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiffCheck(taskId: string, mergeRecordOptions?: Array<'add' | 'update' | 'delete' | 'override'>, query?: string, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BranchDiffRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiffCheck(taskId, mergeRecordOptions, query, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * list
         * @summary list
         * @param {string} gridId gridId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(gridId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Branch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(gridId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * merge
         * @summary merge
         * @param {string} branchId branchId
         * @param {string} destinationBranchId destinationBranchId
         * @param {MergeBranchRequest} mergeBranchRequest 
         * @param {Array<'add' | 'update' | 'delete' | 'override'>} [mergeRecordOptions] mergeRecordOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async merge(branchId: string, destinationBranchId: string, mergeBranchRequest: MergeBranchRequest, mergeRecordOptions?: Array<'add' | 'update' | 'delete' | 'override'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.merge(branchId, destinationBranchId, mergeBranchRequest, mergeRecordOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BranchApi - factory interface
 * @export
 */
export const BranchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BranchApiFp(configuration)
    return {
        /**
         * delete
         * @summary delete
         * @param {string} branchId branchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(branchId: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * create
         * @summary create
         * @param {CreateBranch} createBranch 
         * @param {string} [gridId] gridId
         * @param {string} [branchId] branchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createBranch: CreateBranch, gridId?: string, branchId?: string, options?: any): AxiosPromise<Branch> {
            return localVarFp.create(createBranch, gridId, branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * createDiffCheck
         * @summary createDiffCheck
         * @param {string} sourceViewId sourceViewId
         * @param {string} destinationViewId destinationViewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiffCheck(sourceViewId: string, destinationViewId: string, options?: any): AxiosPromise<Task> {
            return localVarFp.createDiffCheck(sourceViewId, destinationViewId, options).then((request) => request(axios, basePath));
        },
        /**
         * get
         * @summary get
         * @param {string} branchId branchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(branchId: string, options?: any): AxiosPromise<Branch> {
            return localVarFp.get(branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * getDiffCheck
         * @summary getDiffCheck
         * @param {string} taskId taskId
         * @param {Array<'add' | 'update' | 'delete' | 'override'>} [mergeRecordOptions] mergeRecordOptions
         * @param {string} [query] query
         * @param {string} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiffCheck(taskId: string, mergeRecordOptions?: Array<'add' | 'update' | 'delete' | 'override'>, query?: string, page?: string, options?: any): AxiosPromise<Array<BranchDiffRecord>> {
            return localVarFp.getDiffCheck(taskId, mergeRecordOptions, query, page, options).then((request) => request(axios, basePath));
        },
        /**
         * list
         * @summary list
         * @param {string} gridId gridId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(gridId: string, options?: any): AxiosPromise<Array<Branch>> {
            return localVarFp.list(gridId, options).then((request) => request(axios, basePath));
        },
        /**
         * merge
         * @summary merge
         * @param {string} branchId branchId
         * @param {string} destinationBranchId destinationBranchId
         * @param {MergeBranchRequest} mergeBranchRequest 
         * @param {Array<'add' | 'update' | 'delete' | 'override'>} [mergeRecordOptions] mergeRecordOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        merge(branchId: string, destinationBranchId: string, mergeBranchRequest: MergeBranchRequest, mergeRecordOptions?: Array<'add' | 'update' | 'delete' | 'override'>, options?: any): AxiosPromise<Task> {
            return localVarFp.merge(branchId, destinationBranchId, mergeBranchRequest, mergeRecordOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BranchApi - object-oriented interface
 * @export
 * @class BranchApi
 * @extends {BaseAPI}
 */
export class BranchApi extends BaseAPI {
    /**
     * delete
     * @summary delete
     * @param {string} branchId branchId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchApi
     */
    public _delete(branchId: string, options?: AxiosRequestConfig) {
        return BranchApiFp(this.configuration)._delete(branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create
     * @summary create
     * @param {CreateBranch} createBranch 
     * @param {string} [gridId] gridId
     * @param {string} [branchId] branchId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchApi
     */
    public create(createBranch: CreateBranch, gridId?: string, branchId?: string, options?: AxiosRequestConfig) {
        return BranchApiFp(this.configuration).create(createBranch, gridId, branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * createDiffCheck
     * @summary createDiffCheck
     * @param {string} sourceViewId sourceViewId
     * @param {string} destinationViewId destinationViewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchApi
     */
    public createDiffCheck(sourceViewId: string, destinationViewId: string, options?: AxiosRequestConfig) {
        return BranchApiFp(this.configuration).createDiffCheck(sourceViewId, destinationViewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get
     * @summary get
     * @param {string} branchId branchId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchApi
     */
    public get(branchId: string, options?: AxiosRequestConfig) {
        return BranchApiFp(this.configuration).get(branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * getDiffCheck
     * @summary getDiffCheck
     * @param {string} taskId taskId
     * @param {Array<'add' | 'update' | 'delete' | 'override'>} [mergeRecordOptions] mergeRecordOptions
     * @param {string} [query] query
     * @param {string} [page] page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchApi
     */
    public getDiffCheck(taskId: string, mergeRecordOptions?: Array<'add' | 'update' | 'delete' | 'override'>, query?: string, page?: string, options?: AxiosRequestConfig) {
        return BranchApiFp(this.configuration).getDiffCheck(taskId, mergeRecordOptions, query, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list
     * @summary list
     * @param {string} gridId gridId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchApi
     */
    public list(gridId: string, options?: AxiosRequestConfig) {
        return BranchApiFp(this.configuration).list(gridId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * merge
     * @summary merge
     * @param {string} branchId branchId
     * @param {string} destinationBranchId destinationBranchId
     * @param {MergeBranchRequest} mergeBranchRequest 
     * @param {Array<'add' | 'update' | 'delete' | 'override'>} [mergeRecordOptions] mergeRecordOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchApi
     */
    public merge(branchId: string, destinationBranchId: string, mergeBranchRequest: MergeBranchRequest, mergeRecordOptions?: Array<'add' | 'update' | 'delete' | 'override'>, options?: AxiosRequestConfig) {
        return BranchApiFp(this.configuration).merge(branchId, destinationBranchId, mergeBranchRequest, mergeRecordOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseApi - axios parameter creator
 * @export
 */
export const DatabaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary delete
         * @param {string} dbId dbId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (dbId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbId' is not null or undefined
            assertParamExists('_delete', 'dbId', dbId)
            const localVarPath = `/v1/databases/{dbId}`
                .replace(`{${"dbId"}}`, encodeURIComponent(String(dbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create
         * @param {number} projectId projectId
         * @param {CreateDatabase} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (projectId: number, body: CreateDatabase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('create', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('create', 'body', body)
            const localVarPath = `/v1/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary duplicate
         * @param {string} dbId dbId
         * @param {number} projectId projectId
         * @param {CreateDatabase} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicate: async (dbId: string, projectId: number, body: CreateDatabase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbId' is not null or undefined
            assertParamExists('duplicate', 'dbId', dbId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('duplicate', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('duplicate', 'body', body)
            const localVarPath = `/v1/databases/{dbId}/duplicate`
                .replace(`{${"dbId"}}`, encodeURIComponent(String(dbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get
         * @param {string} dbId dbId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (dbId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbId' is not null or undefined
            assertParamExists('get', 'dbId', dbId)
            const localVarPath = `/v1/databases/{dbId}`
                .replace(`{${"dbId"}}`, encodeURIComponent(String(dbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list
         * @param {Array<'grid' | 'view'>} [expand] expand
         * @param {string} [page] page
         * @param {number} [projectId] projectId
         * @param {string} [search] search
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (expand?: Array<'grid' | 'view'>, page?: string, projectId?: number, search?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update
         * @param {string} dbId dbId
         * @param {UpdateDatabase} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (dbId: string, body: UpdateDatabase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbId' is not null or undefined
            assertParamExists('update', 'dbId', dbId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('update', 'body', body)
            const localVarPath = `/v1/databases/{dbId}`
                .replace(`{${"dbId"}}`, encodeURIComponent(String(dbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseApi - functional programming interface
 * @export
 */
export const DatabaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary delete
         * @param {string} dbId dbId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(dbId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(dbId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create
         * @param {number} projectId projectId
         * @param {CreateDatabase} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(projectId: number, body: CreateDatabase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(projectId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary duplicate
         * @param {string} dbId dbId
         * @param {number} projectId projectId
         * @param {CreateDatabase} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async duplicate(dbId: string, projectId: number, body: CreateDatabase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.duplicate(dbId, projectId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get
         * @param {string} dbId dbId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(dbId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(dbId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary list
         * @param {Array<'grid' | 'view'>} [expand] expand
         * @param {string} [page] page
         * @param {number} [projectId] projectId
         * @param {string} [search] search
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(expand?: Array<'grid' | 'view'>, page?: string, projectId?: number, search?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Database>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(expand, page, projectId, search, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update
         * @param {string} dbId dbId
         * @param {UpdateDatabase} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(dbId: string, body: UpdateDatabase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(dbId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseApi - factory interface
 * @export
 */
export const DatabaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseApiFp(configuration)
    return {
        /**
         * 
         * @summary delete
         * @param {string} dbId dbId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(dbId: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(dbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create
         * @param {number} projectId projectId
         * @param {CreateDatabase} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(projectId: number, body: CreateDatabase, options?: any): AxiosPromise<Database> {
            return localVarFp.create(projectId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary duplicate
         * @param {string} dbId dbId
         * @param {number} projectId projectId
         * @param {CreateDatabase} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicate(dbId: string, projectId: number, body: CreateDatabase, options?: any): AxiosPromise<Database> {
            return localVarFp.duplicate(dbId, projectId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get
         * @param {string} dbId dbId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(dbId: string, options?: any): AxiosPromise<Database> {
            return localVarFp.get(dbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary list
         * @param {Array<'grid' | 'view'>} [expand] expand
         * @param {string} [page] page
         * @param {number} [projectId] projectId
         * @param {string} [search] search
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(expand?: Array<'grid' | 'view'>, page?: string, projectId?: number, search?: string, sort?: string, options?: any): AxiosPromise<Array<Database>> {
            return localVarFp.list(expand, page, projectId, search, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update
         * @param {string} dbId dbId
         * @param {UpdateDatabase} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(dbId: string, body: UpdateDatabase, options?: any): AxiosPromise<Database> {
            return localVarFp.update(dbId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseApi - object-oriented interface
 * @export
 * @class DatabaseApi
 * @extends {BaseAPI}
 */
export class DatabaseApi extends BaseAPI {
    /**
     * 
     * @summary delete
     * @param {string} dbId dbId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public _delete(dbId: string, options?: AxiosRequestConfig) {
        return DatabaseApiFp(this.configuration)._delete(dbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create
     * @param {number} projectId projectId
     * @param {CreateDatabase} body body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public create(projectId: number, body: CreateDatabase, options?: AxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).create(projectId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary duplicate
     * @param {string} dbId dbId
     * @param {number} projectId projectId
     * @param {CreateDatabase} body body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public duplicate(dbId: string, projectId: number, body: CreateDatabase, options?: AxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).duplicate(dbId, projectId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get
     * @param {string} dbId dbId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public get(dbId: string, options?: AxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).get(dbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary list
     * @param {Array<'grid' | 'view'>} [expand] expand
     * @param {string} [page] page
     * @param {number} [projectId] projectId
     * @param {string} [search] search
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public list(expand?: Array<'grid' | 'view'>, page?: string, projectId?: number, search?: string, sort?: string, options?: AxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).list(expand, page, projectId, search, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update
     * @param {string} dbId dbId
     * @param {UpdateDatabase} body body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public update(dbId: string, body: UpdateDatabase, options?: AxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).update(dbId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GlossaryApi - axios parameter creator
 * @export
 */
export const GlossaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a glossary
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/v1/glossaries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new glossary
         * @param {CreateGlossary} [createGlossary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createGlossary?: CreateGlossary, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/glossaries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGlossary, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export a glossary
         * @param {number} id 
         * @param {Array<string>} [fields] 
         * @param {GlossaryExportFormat} [format] 
         * @param {Array<string>} [langs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportFile: async (id: number, fields?: Array<string>, format?: GlossaryExportFormat, langs?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportFile', 'id', id)
            const localVarPath = `/v1/glossaries/{id}/export`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (langs) {
                localVarQueryParameter['langs'] = langs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get glossary info
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('get', 'id', id)
            const localVarPath = `/v1/glossaries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all glossaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/glossaries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import a glossary from file
         * @param {number} id 
         * @param {ImportOption} [importOption] 
         * @param {object} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFile: async (id: number, importOption?: ImportOption, file?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importFile', 'id', id)
            const localVarPath = `/v1/glossaries/{id}/import`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (importOption !== undefined) {
                localVarQueryParameter['importOption'] = importOption;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', new Blob([JSON.stringify(file)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update glossary info
         * @param {number} id 
         * @param {UpdateGlossary} [updateGlossary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: number, updateGlossary?: UpdateGlossary, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/glossaries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGlossary, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GlossaryApi - functional programming interface
 * @export
 */
export const GlossaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GlossaryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a glossary
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new glossary
         * @param {CreateGlossary} [createGlossary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createGlossary?: CreateGlossary, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Glossary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(createGlossary, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Export a glossary
         * @param {number} id 
         * @param {Array<string>} [fields] 
         * @param {GlossaryExportFormat} [format] 
         * @param {Array<string>} [langs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportFile(id: number, fields?: Array<string>, format?: GlossaryExportFormat, langs?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportFile(id, fields, format, langs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get glossary info
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Glossary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all glossaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Glossary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import a glossary from file
         * @param {number} id 
         * @param {ImportOption} [importOption] 
         * @param {object} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importFile(id: number, importOption?: ImportOption, file?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importFile(id, importOption, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update glossary info
         * @param {number} id 
         * @param {UpdateGlossary} [updateGlossary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: number, updateGlossary?: UpdateGlossary, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, updateGlossary, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GlossaryApi - factory interface
 * @export
 */
export const GlossaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GlossaryApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a glossary
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new glossary
         * @param {CreateGlossary} [createGlossary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createGlossary?: CreateGlossary, options?: any): AxiosPromise<Glossary> {
            return localVarFp.create(createGlossary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export a glossary
         * @param {number} id 
         * @param {Array<string>} [fields] 
         * @param {GlossaryExportFormat} [format] 
         * @param {Array<string>} [langs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportFile(id: number, fields?: Array<string>, format?: GlossaryExportFormat, langs?: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.exportFile(id, fields, format, langs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get glossary info
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, options?: any): AxiosPromise<Glossary> {
            return localVarFp.get(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all glossaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(options?: any): AxiosPromise<Array<Glossary>> {
            return localVarFp.getAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import a glossary from file
         * @param {number} id 
         * @param {ImportOption} [importOption] 
         * @param {object} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFile(id: number, importOption?: ImportOption, file?: object, options?: any): AxiosPromise<void> {
            return localVarFp.importFile(id, importOption, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update glossary info
         * @param {number} id 
         * @param {UpdateGlossary} [updateGlossary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: number, updateGlossary?: UpdateGlossary, options?: any): AxiosPromise<void> {
            return localVarFp.update(id, updateGlossary, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GlossaryApi - object-oriented interface
 * @export
 * @class GlossaryApi
 * @extends {BaseAPI}
 */
export class GlossaryApi extends BaseAPI {
    /**
     * 
     * @summary Delete a glossary
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlossaryApi
     */
    public _delete(id: number, options?: AxiosRequestConfig) {
        return GlossaryApiFp(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new glossary
     * @param {CreateGlossary} [createGlossary] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlossaryApi
     */
    public create(createGlossary?: CreateGlossary, options?: AxiosRequestConfig) {
        return GlossaryApiFp(this.configuration).create(createGlossary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export a glossary
     * @param {number} id 
     * @param {Array<string>} [fields] 
     * @param {GlossaryExportFormat} [format] 
     * @param {Array<string>} [langs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlossaryApi
     */
    public exportFile(id: number, fields?: Array<string>, format?: GlossaryExportFormat, langs?: Array<string>, options?: AxiosRequestConfig) {
        return GlossaryApiFp(this.configuration).exportFile(id, fields, format, langs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get glossary info
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlossaryApi
     */
    public get(id: number, options?: AxiosRequestConfig) {
        return GlossaryApiFp(this.configuration).get(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all glossaries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlossaryApi
     */
    public getAll(options?: AxiosRequestConfig) {
        return GlossaryApiFp(this.configuration).getAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import a glossary from file
     * @param {number} id 
     * @param {ImportOption} [importOption] 
     * @param {object} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlossaryApi
     */
    public importFile(id: number, importOption?: ImportOption, file?: object, options?: AxiosRequestConfig) {
        return GlossaryApiFp(this.configuration).importFile(id, importOption, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update glossary info
     * @param {number} id 
     * @param {UpdateGlossary} [updateGlossary] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlossaryApi
     */
    public update(id: number, updateGlossary?: UpdateGlossary, options?: AxiosRequestConfig) {
        return GlossaryApiFp(this.configuration).update(id, updateGlossary, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GridApi - axios parameter creator
 * @export
 */
export const GridApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a Grid
         * @summary delete
         * @param {string} gridId gridId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (gridId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gridId' is not null or undefined
            assertParamExists('_delete', 'gridId', gridId)
            const localVarPath = `/v1/grids/{gridId}`
                .replace(`{${"gridId"}}`, encodeURIComponent(String(gridId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Grid
         * @summary create
         * @param {string} dbId dbId
         * @param {CreateGrid} createGrid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (dbId: string, createGrid: CreateGrid, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbId' is not null or undefined
            assertParamExists('create', 'dbId', dbId)
            // verify required parameter 'createGrid' is not null or undefined
            assertParamExists('create', 'createGrid', createGrid)
            const localVarPath = `/v1/grids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (dbId !== undefined) {
                localVarQueryParameter['dbId'] = dbId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGrid, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * createCategory
         * @summary createCategory
         * @param {string} gridId gridId
         * @param {CreateFileCategory} createFileCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory: async (gridId: string, createFileCategory: CreateFileCategory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gridId' is not null or undefined
            assertParamExists('createCategory', 'gridId', gridId)
            // verify required parameter 'createFileCategory' is not null or undefined
            assertParamExists('createCategory', 'createFileCategory', createFileCategory)
            const localVarPath = `/v1/grids/{gridId}/settings/categories`
                .replace(`{${"gridId"}}`, encodeURIComponent(String(gridId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFileCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * deleteCategory
         * @summary deleteCategory
         * @param {string} gridId gridId
         * @param {string} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (gridId: string, categoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gridId' is not null or undefined
            assertParamExists('deleteCategory', 'gridId', gridId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('deleteCategory', 'categoryId', categoryId)
            const localVarPath = `/v1/grids/{gridId}/settings/categories/{categoryId}`
                .replace(`{${"gridId"}}`, encodeURIComponent(String(gridId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * deleteFile
         * @summary deleteFile
         * @param {string} gridId gridId
         * @param {string} categoryId categoryId
         * @param {string} fileId fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (gridId: string, categoryId: string, fileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gridId' is not null or undefined
            assertParamExists('deleteFile', 'gridId', gridId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('deleteFile', 'categoryId', categoryId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteFile', 'fileId', fileId)
            const localVarPath = `/v1/grids/{gridId}/settings/categories/{categoryId}/files/{fileId}`
                .replace(`{${"gridId"}}`, encodeURIComponent(String(gridId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Grid
         * @summary get
         * @param {string} gridId gridId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (gridId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gridId' is not null or undefined
            assertParamExists('get', 'gridId', gridId)
            const localVarPath = `/v1/grids/{gridId}`
                .replace(`{${"gridId"}}`, encodeURIComponent(String(gridId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * getSetting
         * @summary getSetting
         * @param {string} gridId gridId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting: async (gridId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gridId' is not null or undefined
            assertParamExists('getSetting', 'gridId', gridId)
            const localVarPath = `/v1/grids/{gridId}/settings`
                .replace(`{${"gridId"}}`, encodeURIComponent(String(gridId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Grid
         * @summary list
         * @param {string} dbId dbId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (dbId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbId' is not null or undefined
            assertParamExists('list', 'dbId', dbId)
            const localVarPath = `/v1/grids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (dbId !== undefined) {
                localVarQueryParameter['dbId'] = dbId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * listFiles
         * @summary listFiles
         * @param {string} gridId gridId
         * @param {Array<string>} [categoryId] categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles: async (gridId: string, categoryId?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gridId' is not null or undefined
            assertParamExists('listFiles', 'gridId', gridId)
            const localVarPath = `/v1/grids/{gridId}/settings/files`
                .replace(`{${"gridId"}}`, encodeURIComponent(String(gridId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (categoryId) {
                localVarQueryParameter['categoryId'] = categoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * listTemplateGrids
         * @summary listTemplateGrids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplateGrids: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/template-grids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Grid
         * @summary update
         * @param {string} gridId gridId
         * @param {UpdateGrid} updateGrid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (gridId: string, updateGrid: UpdateGrid, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gridId' is not null or undefined
            assertParamExists('update', 'gridId', gridId)
            // verify required parameter 'updateGrid' is not null or undefined
            assertParamExists('update', 'updateGrid', updateGrid)
            const localVarPath = `/v1/grids/{gridId}`
                .replace(`{${"gridId"}}`, encodeURIComponent(String(gridId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGrid, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * updateCategory
         * @summary updateCategory
         * @param {string} gridId gridId
         * @param {string} categoryId categoryId
         * @param {UpdateCategory} updateCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (gridId: string, categoryId: string, updateCategory: UpdateCategory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gridId' is not null or undefined
            assertParamExists('updateCategory', 'gridId', gridId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('updateCategory', 'categoryId', categoryId)
            // verify required parameter 'updateCategory' is not null or undefined
            assertParamExists('updateCategory', 'updateCategory', updateCategory)
            const localVarPath = `/v1/grids/{gridId}/settings/categories/{categoryId}`
                .replace(`{${"gridId"}}`, encodeURIComponent(String(gridId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * updateSetting
         * @summary updateSetting
         * @param {string} gridId gridId
         * @param {UpdateGridSetting} updateGridSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting: async (gridId: string, updateGridSetting: UpdateGridSetting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gridId' is not null or undefined
            assertParamExists('updateSetting', 'gridId', gridId)
            // verify required parameter 'updateGridSetting' is not null or undefined
            assertParamExists('updateSetting', 'updateGridSetting', updateGridSetting)
            const localVarPath = `/v1/grids/{gridId}/settings`
                .replace(`{${"gridId"}}`, encodeURIComponent(String(gridId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGridSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * uploadSettingFile
         * @summary uploadSettingFile
         * @param {string} gridId gridId
         * @param {string} categoryId categoryId
         * @param {UploadSettingFileRequest} uploadSettingFileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSettingFile: async (gridId: string, categoryId: string, uploadSettingFileRequest: UploadSettingFileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gridId' is not null or undefined
            assertParamExists('uploadSettingFile', 'gridId', gridId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('uploadSettingFile', 'categoryId', categoryId)
            // verify required parameter 'uploadSettingFileRequest' is not null or undefined
            assertParamExists('uploadSettingFile', 'uploadSettingFileRequest', uploadSettingFileRequest)
            const localVarPath = `/v1/grids/{gridId}/settings/categories/{categoryId}/files`
                .replace(`{${"gridId"}}`, encodeURIComponent(String(gridId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadSettingFileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GridApi - functional programming interface
 * @export
 */
export const GridApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GridApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a Grid
         * @summary delete
         * @param {string} gridId gridId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(gridId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(gridId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Grid
         * @summary create
         * @param {string} dbId dbId
         * @param {CreateGrid} createGrid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(dbId: string, createGrid: CreateGrid, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Grid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(dbId, createGrid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * createCategory
         * @summary createCategory
         * @param {string} gridId gridId
         * @param {CreateFileCategory} createFileCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCategory(gridId: string, createFileCategory: CreateFileCategory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(gridId, createFileCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * deleteCategory
         * @summary deleteCategory
         * @param {string} gridId gridId
         * @param {string} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(gridId: string, categoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(gridId, categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * deleteFile
         * @summary deleteFile
         * @param {string} gridId gridId
         * @param {string} categoryId categoryId
         * @param {string} fileId fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(gridId: string, categoryId: string, fileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(gridId, categoryId, fileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a Grid
         * @summary get
         * @param {string} gridId gridId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(gridId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Grid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(gridId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * getSetting
         * @summary getSetting
         * @param {string} gridId gridId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSetting(gridId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GridSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSetting(gridId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a Grid
         * @summary list
         * @param {string} dbId dbId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(dbId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Grid>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(dbId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * listFiles
         * @summary listFiles
         * @param {string} gridId gridId
         * @param {Array<string>} [categoryId] categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFiles(gridId: string, categoryId?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SettingFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFiles(gridId, categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * listTemplateGrids
         * @summary listTemplateGrids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTemplateGrids(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Grid>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTemplateGrids(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Grid
         * @summary update
         * @param {string} gridId gridId
         * @param {UpdateGrid} updateGrid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(gridId: string, updateGrid: UpdateGrid, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Grid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(gridId, updateGrid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * updateCategory
         * @summary updateCategory
         * @param {string} gridId gridId
         * @param {string} categoryId categoryId
         * @param {UpdateCategory} updateCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(gridId: string, categoryId: string, updateCategory: UpdateCategory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(gridId, categoryId, updateCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * updateSetting
         * @summary updateSetting
         * @param {string} gridId gridId
         * @param {UpdateGridSetting} updateGridSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSetting(gridId: string, updateGridSetting: UpdateGridSetting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GridSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSetting(gridId, updateGridSetting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * uploadSettingFile
         * @summary uploadSettingFile
         * @param {string} gridId gridId
         * @param {string} categoryId categoryId
         * @param {UploadSettingFileRequest} uploadSettingFileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadSettingFile(gridId: string, categoryId: string, uploadSettingFileRequest: UploadSettingFileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadedFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadSettingFile(gridId, categoryId, uploadSettingFileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GridApi - factory interface
 * @export
 */
export const GridApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GridApiFp(configuration)
    return {
        /**
         * Delete a Grid
         * @summary delete
         * @param {string} gridId gridId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(gridId: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(gridId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Grid
         * @summary create
         * @param {string} dbId dbId
         * @param {CreateGrid} createGrid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(dbId: string, createGrid: CreateGrid, options?: any): AxiosPromise<Grid> {
            return localVarFp.create(dbId, createGrid, options).then((request) => request(axios, basePath));
        },
        /**
         * createCategory
         * @summary createCategory
         * @param {string} gridId gridId
         * @param {CreateFileCategory} createFileCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(gridId: string, createFileCategory: CreateFileCategory, options?: any): AxiosPromise<FileCategory> {
            return localVarFp.createCategory(gridId, createFileCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * deleteCategory
         * @summary deleteCategory
         * @param {string} gridId gridId
         * @param {string} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(gridId: string, categoryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategory(gridId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * deleteFile
         * @summary deleteFile
         * @param {string} gridId gridId
         * @param {string} categoryId categoryId
         * @param {string} fileId fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(gridId: string, categoryId: string, fileId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFile(gridId, categoryId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Grid
         * @summary get
         * @param {string} gridId gridId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(gridId: string, options?: any): AxiosPromise<Grid> {
            return localVarFp.get(gridId, options).then((request) => request(axios, basePath));
        },
        /**
         * getSetting
         * @summary getSetting
         * @param {string} gridId gridId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting(gridId: string, options?: any): AxiosPromise<GridSetting> {
            return localVarFp.getSetting(gridId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Grid
         * @summary list
         * @param {string} dbId dbId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(dbId: string, options?: any): AxiosPromise<Array<Grid>> {
            return localVarFp.list(dbId, options).then((request) => request(axios, basePath));
        },
        /**
         * listFiles
         * @summary listFiles
         * @param {string} gridId gridId
         * @param {Array<string>} [categoryId] categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles(gridId: string, categoryId?: Array<string>, options?: any): AxiosPromise<Array<SettingFile>> {
            return localVarFp.listFiles(gridId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * listTemplateGrids
         * @summary listTemplateGrids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplateGrids(options?: any): AxiosPromise<Array<Grid>> {
            return localVarFp.listTemplateGrids(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Grid
         * @summary update
         * @param {string} gridId gridId
         * @param {UpdateGrid} updateGrid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(gridId: string, updateGrid: UpdateGrid, options?: any): AxiosPromise<Grid> {
            return localVarFp.update(gridId, updateGrid, options).then((request) => request(axios, basePath));
        },
        /**
         * updateCategory
         * @summary updateCategory
         * @param {string} gridId gridId
         * @param {string} categoryId categoryId
         * @param {UpdateCategory} updateCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(gridId: string, categoryId: string, updateCategory: UpdateCategory, options?: any): AxiosPromise<FileCategory> {
            return localVarFp.updateCategory(gridId, categoryId, updateCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * updateSetting
         * @summary updateSetting
         * @param {string} gridId gridId
         * @param {UpdateGridSetting} updateGridSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting(gridId: string, updateGridSetting: UpdateGridSetting, options?: any): AxiosPromise<GridSetting> {
            return localVarFp.updateSetting(gridId, updateGridSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * uploadSettingFile
         * @summary uploadSettingFile
         * @param {string} gridId gridId
         * @param {string} categoryId categoryId
         * @param {UploadSettingFileRequest} uploadSettingFileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSettingFile(gridId: string, categoryId: string, uploadSettingFileRequest: UploadSettingFileRequest, options?: any): AxiosPromise<UploadedFile> {
            return localVarFp.uploadSettingFile(gridId, categoryId, uploadSettingFileRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GridApi - object-oriented interface
 * @export
 * @class GridApi
 * @extends {BaseAPI}
 */
export class GridApi extends BaseAPI {
    /**
     * Delete a Grid
     * @summary delete
     * @param {string} gridId gridId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public _delete(gridId: string, options?: AxiosRequestConfig) {
        return GridApiFp(this.configuration)._delete(gridId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Grid
     * @summary create
     * @param {string} dbId dbId
     * @param {CreateGrid} createGrid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public create(dbId: string, createGrid: CreateGrid, options?: AxiosRequestConfig) {
        return GridApiFp(this.configuration).create(dbId, createGrid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * createCategory
     * @summary createCategory
     * @param {string} gridId gridId
     * @param {CreateFileCategory} createFileCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public createCategory(gridId: string, createFileCategory: CreateFileCategory, options?: AxiosRequestConfig) {
        return GridApiFp(this.configuration).createCategory(gridId, createFileCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * deleteCategory
     * @summary deleteCategory
     * @param {string} gridId gridId
     * @param {string} categoryId categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public deleteCategory(gridId: string, categoryId: string, options?: AxiosRequestConfig) {
        return GridApiFp(this.configuration).deleteCategory(gridId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * deleteFile
     * @summary deleteFile
     * @param {string} gridId gridId
     * @param {string} categoryId categoryId
     * @param {string} fileId fileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public deleteFile(gridId: string, categoryId: string, fileId: string, options?: AxiosRequestConfig) {
        return GridApiFp(this.configuration).deleteFile(gridId, categoryId, fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Grid
     * @summary get
     * @param {string} gridId gridId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public get(gridId: string, options?: AxiosRequestConfig) {
        return GridApiFp(this.configuration).get(gridId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * getSetting
     * @summary getSetting
     * @param {string} gridId gridId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public getSetting(gridId: string, options?: AxiosRequestConfig) {
        return GridApiFp(this.configuration).getSetting(gridId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Grid
     * @summary list
     * @param {string} dbId dbId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public list(dbId: string, options?: AxiosRequestConfig) {
        return GridApiFp(this.configuration).list(dbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * listFiles
     * @summary listFiles
     * @param {string} gridId gridId
     * @param {Array<string>} [categoryId] categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public listFiles(gridId: string, categoryId?: Array<string>, options?: AxiosRequestConfig) {
        return GridApiFp(this.configuration).listFiles(gridId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * listTemplateGrids
     * @summary listTemplateGrids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public listTemplateGrids(options?: AxiosRequestConfig) {
        return GridApiFp(this.configuration).listTemplateGrids(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Grid
     * @summary update
     * @param {string} gridId gridId
     * @param {UpdateGrid} updateGrid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public update(gridId: string, updateGrid: UpdateGrid, options?: AxiosRequestConfig) {
        return GridApiFp(this.configuration).update(gridId, updateGrid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * updateCategory
     * @summary updateCategory
     * @param {string} gridId gridId
     * @param {string} categoryId categoryId
     * @param {UpdateCategory} updateCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public updateCategory(gridId: string, categoryId: string, updateCategory: UpdateCategory, options?: AxiosRequestConfig) {
        return GridApiFp(this.configuration).updateCategory(gridId, categoryId, updateCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * updateSetting
     * @summary updateSetting
     * @param {string} gridId gridId
     * @param {UpdateGridSetting} updateGridSetting 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public updateSetting(gridId: string, updateGridSetting: UpdateGridSetting, options?: AxiosRequestConfig) {
        return GridApiFp(this.configuration).updateSetting(gridId, updateGridSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * uploadSettingFile
     * @summary uploadSettingFile
     * @param {string} gridId gridId
     * @param {string} categoryId categoryId
     * @param {UploadSettingFileRequest} uploadSettingFileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public uploadSettingFile(gridId: string, categoryId: string, uploadSettingFileRequest: UploadSettingFileRequest, options?: AxiosRequestConfig) {
        return GridApiFp(this.configuration).uploadSettingFile(gridId, categoryId, uploadSettingFileRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PathApi - axios parameter creator
 * @export
 */
export const PathApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete
         * @summary delete
         * @param {string} viewId viewId
         * @param {DeletePath} deletePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (viewId: string, deletePath: DeletePath, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('_delete', 'viewId', viewId)
            // verify required parameter 'deletePath' is not null or undefined
            assertParamExists('_delete', 'deletePath', deletePath)
            const localVarPath = `/v1/views/{viewId}/paths`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePath, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create
         * @summary create
         * @param {string} viewId viewId
         * @param {CreatePath} createPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (viewId: string, createPath: CreatePath, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('create', 'viewId', viewId)
            // verify required parameter 'createPath' is not null or undefined
            assertParamExists('create', 'createPath', createPath)
            const localVarPath = `/v1/views/{viewId}/paths`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPath, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list
         * @summary list
         * @param {string} viewId viewId
         * @param {string} [rootPath] rootPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (viewId: string, rootPath?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('list', 'viewId', viewId)
            const localVarPath = `/v1/views/{viewId}/paths/tree`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (rootPath !== undefined) {
                localVarQueryParameter['rootPath'] = rootPath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * move
         * @summary move
         * @param {string} viewId viewId
         * @param {MovePath} movePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move: async (viewId: string, movePath: MovePath, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('move', 'viewId', viewId)
            // verify required parameter 'movePath' is not null or undefined
            assertParamExists('move', 'movePath', movePath)
            const localVarPath = `/v1/views/{viewId}/paths/move`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(movePath, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update
         * @summary update
         * @param {string} viewId viewId
         * @param {string} path path
         * @param {UpdatePath} updatePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (viewId: string, path: string, updatePath: UpdatePath, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('update', 'viewId', viewId)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('update', 'path', path)
            // verify required parameter 'updatePath' is not null or undefined
            assertParamExists('update', 'updatePath', updatePath)
            const localVarPath = `/v1/views/{viewId}/paths/{path}`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePath, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PathApi - functional programming interface
 * @export
 */
export const PathApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PathApiAxiosParamCreator(configuration)
    return {
        /**
         * delete
         * @summary delete
         * @param {string} viewId viewId
         * @param {DeletePath} deletePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(viewId: string, deletePath: DeletePath, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(viewId, deletePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create
         * @summary create
         * @param {string} viewId viewId
         * @param {CreatePath} createPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(viewId: string, createPath: CreatePath, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PathList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(viewId, createPath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * list
         * @summary list
         * @param {string} viewId viewId
         * @param {string} [rootPath] rootPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(viewId: string, rootPath?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PathNode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(viewId, rootPath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * move
         * @summary move
         * @param {string} viewId viewId
         * @param {MovePath} movePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async move(viewId: string, movePath: MovePath, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PathList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.move(viewId, movePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update
         * @summary update
         * @param {string} viewId viewId
         * @param {string} path path
         * @param {UpdatePath} updatePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(viewId: string, path: string, updatePath: UpdatePath, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PathSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(viewId, path, updatePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PathApi - factory interface
 * @export
 */
export const PathApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PathApiFp(configuration)
    return {
        /**
         * delete
         * @summary delete
         * @param {string} viewId viewId
         * @param {DeletePath} deletePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(viewId: string, deletePath: DeletePath, options?: any): AxiosPromise<void> {
            return localVarFp._delete(viewId, deletePath, options).then((request) => request(axios, basePath));
        },
        /**
         * create
         * @summary create
         * @param {string} viewId viewId
         * @param {CreatePath} createPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(viewId: string, createPath: CreatePath, options?: any): AxiosPromise<PathList> {
            return localVarFp.create(viewId, createPath, options).then((request) => request(axios, basePath));
        },
        /**
         * list
         * @summary list
         * @param {string} viewId viewId
         * @param {string} [rootPath] rootPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(viewId: string, rootPath?: string, options?: any): AxiosPromise<Array<PathNode>> {
            return localVarFp.list(viewId, rootPath, options).then((request) => request(axios, basePath));
        },
        /**
         * move
         * @summary move
         * @param {string} viewId viewId
         * @param {MovePath} movePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move(viewId: string, movePath: MovePath, options?: any): AxiosPromise<PathList> {
            return localVarFp.move(viewId, movePath, options).then((request) => request(axios, basePath));
        },
        /**
         * update
         * @summary update
         * @param {string} viewId viewId
         * @param {string} path path
         * @param {UpdatePath} updatePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(viewId: string, path: string, updatePath: UpdatePath, options?: any): AxiosPromise<PathSingle> {
            return localVarFp.update(viewId, path, updatePath, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PathApi - object-oriented interface
 * @export
 * @class PathApi
 * @extends {BaseAPI}
 */
export class PathApi extends BaseAPI {
    /**
     * delete
     * @summary delete
     * @param {string} viewId viewId
     * @param {DeletePath} deletePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathApi
     */
    public _delete(viewId: string, deletePath: DeletePath, options?: AxiosRequestConfig) {
        return PathApiFp(this.configuration)._delete(viewId, deletePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create
     * @summary create
     * @param {string} viewId viewId
     * @param {CreatePath} createPath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathApi
     */
    public create(viewId: string, createPath: CreatePath, options?: AxiosRequestConfig) {
        return PathApiFp(this.configuration).create(viewId, createPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list
     * @summary list
     * @param {string} viewId viewId
     * @param {string} [rootPath] rootPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathApi
     */
    public list(viewId: string, rootPath?: string, options?: AxiosRequestConfig) {
        return PathApiFp(this.configuration).list(viewId, rootPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * move
     * @summary move
     * @param {string} viewId viewId
     * @param {MovePath} movePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathApi
     */
    public move(viewId: string, movePath: MovePath, options?: AxiosRequestConfig) {
        return PathApiFp(this.configuration).move(viewId, movePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update
     * @summary update
     * @param {string} viewId viewId
     * @param {string} path path
     * @param {UpdatePath} updatePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PathApi
     */
    public update(viewId: string, path: string, updatePath: UpdatePath, options?: AxiosRequestConfig) {
        return PathApiFp(this.configuration).update(viewId, path, updatePath, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary delete
         * @param {number} projectId projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (projectId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('_delete', 'projectId', projectId)
            const localVarPath = `/v1/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create
         * @param {CreateProject} createProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createProject: CreateProject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProject' is not null or undefined
            assertParamExists('create', 'createProject', createProject)
            const localVarPath = `/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findOne
         * @param {number} projectId projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOne: async (projectId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findOne', 'projectId', projectId)
            const localVarPath = `/v1/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update
         * @param {number} projectId projectId
         * @param {UpdateProject} updateProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (projectId: number, updateProject: UpdateProject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('update', 'projectId', projectId)
            // verify required parameter 'updateProject' is not null or undefined
            assertParamExists('update', 'updateProject', updateProject)
            const localVarPath = `/v1/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary delete
         * @param {number} projectId projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(projectId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create
         * @param {CreateProject} createProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createProject: CreateProject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(createProject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary findOne
         * @param {number} projectId projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOne(projectId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOne(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update
         * @param {number} projectId projectId
         * @param {UpdateProject} updateProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(projectId: number, updateProject: UpdateProject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(projectId, updateProject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * 
         * @summary delete
         * @param {number} projectId projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(projectId: number, options?: any): AxiosPromise<void> {
            return localVarFp._delete(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create
         * @param {CreateProject} createProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createProject: CreateProject, options?: any): AxiosPromise<Project> {
            return localVarFp.create(createProject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary findOne
         * @param {number} projectId projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOne(projectId: number, options?: any): AxiosPromise<ProjectDetail> {
            return localVarFp.findOne(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: any): AxiosPromise<Array<Project>> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update
         * @param {number} projectId projectId
         * @param {UpdateProject} updateProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(projectId: number, updateProject: UpdateProject, options?: any): AxiosPromise<Project> {
            return localVarFp.update(projectId, updateProject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary delete
     * @param {number} projectId projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public _delete(projectId: number, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration)._delete(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create
     * @param {CreateProject} createProject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public create(createProject: CreateProject, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).create(createProject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary findOne
     * @param {number} projectId projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public findOne(projectId: number, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).findOne(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public list(options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update
     * @param {number} projectId projectId
     * @param {UpdateProject} updateProject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public update(projectId: number, updateProject: UpdateProject, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).update(projectId, updateProject, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RecordApi - axios parameter creator
 * @export
 */
export const RecordApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete
         * @summary delete
         * @param {string} viewId viewId
         * @param {DeleteRecord} deleteRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (viewId: string, deleteRecord: DeleteRecord, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('_delete', 'viewId', viewId)
            // verify required parameter 'deleteRecord' is not null or undefined
            assertParamExists('_delete', 'deleteRecord', deleteRecord)
            const localVarPath = `/v1/views/{viewId}/records`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteRecord, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create
         * @summary create
         * @param {string} viewId viewId
         * @param {Array<SetRecord>} createRecords createRecords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (viewId: string, createRecords: Array<SetRecord>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('create', 'viewId', viewId)
            // verify required parameter 'createRecords' is not null or undefined
            assertParamExists('create', 'createRecords', createRecords)
            const localVarPath = `/v1/views/{viewId}/records`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRecords, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * fetch
         * @summary fetch
         * @param {string} viewId viewId
         * @param {Array<string>} [columnIds] columnIds
         * @param {string} [page] page
         * @param {string} [query] query
         * @param {string} [sort] sort
         * @param {FetchFileOption} [fetchFileOption] fetchFileOption
         * @param {string} [afterRecordId] afterRecordId
         * @param {string} [beforeRecordId] beforeRecordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetch: async (viewId: string, columnIds?: Array<string>, page?: string, query?: string, sort?: string, fetchFileOption?: FetchFileOption, afterRecordId?: string, beforeRecordId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('fetch', 'viewId', viewId)
            const localVarPath = `/v1/views/{viewId}/records`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (columnIds) {
                localVarQueryParameter['columnIds'] = columnIds;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fetchFileOption !== undefined) {
                localVarQueryParameter['fetchFileOption'] = fetchFileOption;
            }

            if (afterRecordId !== undefined) {
                localVarQueryParameter['afterRecordId'] = afterRecordId;
            }

            if (beforeRecordId !== undefined) {
                localVarQueryParameter['beforeRecordId'] = beforeRecordId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * fetchHistories
         * @summary fetchHistories
         * @param {string} viewId viewId
         * @param {string} recordId recordId
         * @param {FetchRecordHistoryRequest} fetchRequest fetchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchHistories: async (viewId: string, recordId: string, fetchRequest: FetchRecordHistoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('fetchHistories', 'viewId', viewId)
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('fetchHistories', 'recordId', recordId)
            // verify required parameter 'fetchRequest' is not null or undefined
            assertParamExists('fetchHistories', 'fetchRequest', fetchRequest)
            const localVarPath = `/v1/views/{viewId}/records/{recordId}/histories`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)))
                .replace(`{${"recordId"}}`, encodeURIComponent(String(recordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fetchRequest !== undefined) {
                localVarQueryParameter['fetchRequest'] = fetchRequest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update
         * @summary update
         * @param {string} viewId viewId
         * @param {Array<SetRecord>} setRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (viewId: string, setRecord: Array<SetRecord>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('update', 'viewId', viewId)
            // verify required parameter 'setRecord' is not null or undefined
            assertParamExists('update', 'setRecord', setRecord)
            const localVarPath = `/v1/views/{viewId}/records`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setRecord, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * updateRecord
         * @summary updateRecord
         * @param {string} id id
         * @param {string} viewId viewId
         * @param {SetRecord} setRecord 
         * @param {string} [path] path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecord: async (id: string, viewId: string, setRecord: SetRecord, path?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRecord', 'id', id)
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('updateRecord', 'viewId', viewId)
            // verify required parameter 'setRecord' is not null or undefined
            assertParamExists('updateRecord', 'setRecord', setRecord)
            const localVarPath = `/v1/views/{viewId}/records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setRecord, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecordApi - functional programming interface
 * @export
 */
export const RecordApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecordApiAxiosParamCreator(configuration)
    return {
        /**
         * delete
         * @summary delete
         * @param {string} viewId viewId
         * @param {DeleteRecord} deleteRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(viewId: string, deleteRecord: DeleteRecord, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(viewId, deleteRecord, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create
         * @summary create
         * @param {string} viewId viewId
         * @param {Array<SetRecord>} createRecords createRecords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(viewId: string, createRecords: Array<SetRecord>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Record>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(viewId, createRecords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * fetch
         * @summary fetch
         * @param {string} viewId viewId
         * @param {Array<string>} [columnIds] columnIds
         * @param {string} [page] page
         * @param {string} [query] query
         * @param {string} [sort] sort
         * @param {FetchFileOption} [fetchFileOption] fetchFileOption
         * @param {string} [afterRecordId] afterRecordId
         * @param {string} [beforeRecordId] beforeRecordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetch(viewId: string, columnIds?: Array<string>, page?: string, query?: string, sort?: string, fetchFileOption?: FetchFileOption, afterRecordId?: string, beforeRecordId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Record>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetch(viewId, columnIds, page, query, sort, fetchFileOption, afterRecordId, beforeRecordId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * fetchHistories
         * @summary fetchHistories
         * @param {string} viewId viewId
         * @param {string} recordId recordId
         * @param {FetchRecordHistoryRequest} fetchRequest fetchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchHistories(viewId: string, recordId: string, fetchRequest: FetchRecordHistoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecordHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchHistories(viewId, recordId, fetchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update
         * @summary update
         * @param {string} viewId viewId
         * @param {Array<SetRecord>} setRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(viewId: string, setRecord: Array<SetRecord>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Record>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(viewId, setRecord, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * updateRecord
         * @summary updateRecord
         * @param {string} id id
         * @param {string} viewId viewId
         * @param {SetRecord} setRecord 
         * @param {string} [path] path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecord(id: string, viewId: string, setRecord: SetRecord, path?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Record>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecord(id, viewId, setRecord, path, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RecordApi - factory interface
 * @export
 */
export const RecordApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecordApiFp(configuration)
    return {
        /**
         * delete
         * @summary delete
         * @param {string} viewId viewId
         * @param {DeleteRecord} deleteRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(viewId: string, deleteRecord: DeleteRecord, options?: any): AxiosPromise<void> {
            return localVarFp._delete(viewId, deleteRecord, options).then((request) => request(axios, basePath));
        },
        /**
         * create
         * @summary create
         * @param {string} viewId viewId
         * @param {Array<SetRecord>} createRecords createRecords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(viewId: string, createRecords: Array<SetRecord>, options?: any): AxiosPromise<Array<Record>> {
            return localVarFp.create(viewId, createRecords, options).then((request) => request(axios, basePath));
        },
        /**
         * fetch
         * @summary fetch
         * @param {string} viewId viewId
         * @param {Array<string>} [columnIds] columnIds
         * @param {string} [page] page
         * @param {string} [query] query
         * @param {string} [sort] sort
         * @param {FetchFileOption} [fetchFileOption] fetchFileOption
         * @param {string} [afterRecordId] afterRecordId
         * @param {string} [beforeRecordId] beforeRecordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetch(viewId: string, columnIds?: Array<string>, page?: string, query?: string, sort?: string, fetchFileOption?: FetchFileOption, afterRecordId?: string, beforeRecordId?: string, options?: any): AxiosPromise<Array<Record>> {
            return localVarFp.fetch(viewId, columnIds, page, query, sort, fetchFileOption, afterRecordId, beforeRecordId, options).then((request) => request(axios, basePath));
        },
        /**
         * fetchHistories
         * @summary fetchHistories
         * @param {string} viewId viewId
         * @param {string} recordId recordId
         * @param {FetchRecordHistoryRequest} fetchRequest fetchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchHistories(viewId: string, recordId: string, fetchRequest: FetchRecordHistoryRequest, options?: any): AxiosPromise<Array<RecordHistory>> {
            return localVarFp.fetchHistories(viewId, recordId, fetchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * update
         * @summary update
         * @param {string} viewId viewId
         * @param {Array<SetRecord>} setRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(viewId: string, setRecord: Array<SetRecord>, options?: any): AxiosPromise<Array<Record>> {
            return localVarFp.update(viewId, setRecord, options).then((request) => request(axios, basePath));
        },
        /**
         * updateRecord
         * @summary updateRecord
         * @param {string} id id
         * @param {string} viewId viewId
         * @param {SetRecord} setRecord 
         * @param {string} [path] path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecord(id: string, viewId: string, setRecord: SetRecord, path?: string, options?: any): AxiosPromise<Record> {
            return localVarFp.updateRecord(id, viewId, setRecord, path, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecordApi - object-oriented interface
 * @export
 * @class RecordApi
 * @extends {BaseAPI}
 */
export class RecordApi extends BaseAPI {
    /**
     * delete
     * @summary delete
     * @param {string} viewId viewId
     * @param {DeleteRecord} deleteRecord 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordApi
     */
    public _delete(viewId: string, deleteRecord: DeleteRecord, options?: AxiosRequestConfig) {
        return RecordApiFp(this.configuration)._delete(viewId, deleteRecord, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create
     * @summary create
     * @param {string} viewId viewId
     * @param {Array<SetRecord>} createRecords createRecords
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordApi
     */
    public create(viewId: string, createRecords: Array<SetRecord>, options?: AxiosRequestConfig) {
        return RecordApiFp(this.configuration).create(viewId, createRecords, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * fetch
     * @summary fetch
     * @param {string} viewId viewId
     * @param {Array<string>} [columnIds] columnIds
     * @param {string} [page] page
     * @param {string} [query] query
     * @param {string} [sort] sort
     * @param {FetchFileOption} [fetchFileOption] fetchFileOption
     * @param {string} [afterRecordId] afterRecordId
     * @param {string} [beforeRecordId] beforeRecordId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordApi
     */
    public fetch(viewId: string, columnIds?: Array<string>, page?: string, query?: string, sort?: string, fetchFileOption?: FetchFileOption, afterRecordId?: string, beforeRecordId?: string, options?: AxiosRequestConfig) {
        return RecordApiFp(this.configuration).fetch(viewId, columnIds, page, query, sort, fetchFileOption, afterRecordId, beforeRecordId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * fetchHistories
     * @summary fetchHistories
     * @param {string} viewId viewId
     * @param {string} recordId recordId
     * @param {FetchRecordHistoryRequest} fetchRequest fetchRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordApi
     */
    public fetchHistories(viewId: string, recordId: string, fetchRequest: FetchRecordHistoryRequest, options?: AxiosRequestConfig) {
        return RecordApiFp(this.configuration).fetchHistories(viewId, recordId, fetchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update
     * @summary update
     * @param {string} viewId viewId
     * @param {Array<SetRecord>} setRecord 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordApi
     */
    public update(viewId: string, setRecord: Array<SetRecord>, options?: AxiosRequestConfig) {
        return RecordApiFp(this.configuration).update(viewId, setRecord, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * updateRecord
     * @summary updateRecord
     * @param {string} id id
     * @param {string} viewId viewId
     * @param {SetRecord} setRecord 
     * @param {string} [path] path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordApi
     */
    public updateRecord(id: string, viewId: string, setRecord: SetRecord, path?: string, options?: AxiosRequestConfig) {
        return RecordApiFp(this.configuration).updateRecord(id, viewId, setRecord, path, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShareViewApi - axios parameter creator
 * @export
 */
export const ShareViewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete
         * @summary delete
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (viewId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('_delete', 'viewId', viewId)
            const localVarPath = `/v1/views/{viewId}/shares`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create
         * @summary create
         * @param {string} viewId viewId
         * @param {CreateShareView} createShareView 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (viewId: string, createShareView: CreateShareView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('create', 'viewId', viewId)
            // verify required parameter 'createShareView' is not null or undefined
            assertParamExists('create', 'createShareView', createShareView)
            const localVarPath = `/v1/views/{viewId}/shares`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createShareView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get
         * @summary get
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (viewId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('get', 'viewId', viewId)
            const localVarPath = `/v1/views/{viewId}/shares`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShareViewApi - functional programming interface
 * @export
 */
export const ShareViewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShareViewApiAxiosParamCreator(configuration)
    return {
        /**
         * delete
         * @summary delete
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(viewId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(viewId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create
         * @summary create
         * @param {string} viewId viewId
         * @param {CreateShareView} createShareView 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(viewId: string, createShareView: CreateShareView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(viewId, createShareView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get
         * @summary get
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(viewId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(viewId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShareViewApi - factory interface
 * @export
 */
export const ShareViewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShareViewApiFp(configuration)
    return {
        /**
         * delete
         * @summary delete
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(viewId: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * create
         * @summary create
         * @param {string} viewId viewId
         * @param {CreateShareView} createShareView 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(viewId: string, createShareView: CreateShareView, options?: any): AxiosPromise<ShareView> {
            return localVarFp.create(viewId, createShareView, options).then((request) => request(axios, basePath));
        },
        /**
         * get
         * @summary get
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(viewId: string, options?: any): AxiosPromise<ShareView> {
            return localVarFp.get(viewId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShareViewApi - object-oriented interface
 * @export
 * @class ShareViewApi
 * @extends {BaseAPI}
 */
export class ShareViewApi extends BaseAPI {
    /**
     * delete
     * @summary delete
     * @param {string} viewId viewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareViewApi
     */
    public _delete(viewId: string, options?: AxiosRequestConfig) {
        return ShareViewApiFp(this.configuration)._delete(viewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create
     * @summary create
     * @param {string} viewId viewId
     * @param {CreateShareView} createShareView 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareViewApi
     */
    public create(viewId: string, createShareView: CreateShareView, options?: AxiosRequestConfig) {
        return ShareViewApiFp(this.configuration).create(viewId, createShareView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get
     * @summary get
     * @param {string} viewId viewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareViewApi
     */
    public get(viewId: string, options?: AxiosRequestConfig) {
        return ShareViewApiFp(this.configuration).get(viewId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get
         * @summary get
         * @param {string} taskId taskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('get', 'taskId', taskId)
            const localVarPath = `/v1/tasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration)
    return {
        /**
         * get
         * @summary get
         * @param {string} taskId taskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskApiFp(configuration)
    return {
        /**
         * get
         * @summary get
         * @param {string} taskId taskId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(taskId: string, options?: any): AxiosPromise<Task> {
            return localVarFp.get(taskId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * get
     * @summary get
     * @param {string} taskId taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public get(taskId: string, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).get(taskId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransmemApi - axios parameter creator
 * @export
 */
export const TransmemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a translation memory by id
         * @param {string} tmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (tmId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tmId' is not null or undefined
            assertParamExists('_delete', 'tmId', tmId)
            const localVarPath = `/v1/transmems/{tmId}`
                .replace(`{${"tmId"}}`, encodeURIComponent(String(tmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export translation memory tmx file
         * @param {string} tmId 
         * @param {ExportFormat} [format] 
         * @param {string} [sourceLang] 
         * @param {Array<string>} [targetLangs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export: async (tmId: string, format?: ExportFormat, sourceLang?: string, targetLangs?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tmId' is not null or undefined
            assertParamExists('_export', 'tmId', tmId)
            const localVarPath = `/v1/transmems/{tmId}/export`
                .replace(`{${"tmId"}}`, encodeURIComponent(String(tmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (sourceLang !== undefined) {
                localVarQueryParameter['sourceLang'] = sourceLang;
            }

            if (targetLangs) {
                localVarQueryParameter['targetLangs'] = targetLangs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Erases all the translation data of the provided tmId
         * @param {string} tmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanup: async (tmId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tmId' is not null or undefined
            assertParamExists('cleanup', 'tmId', tmId)
            const localVarPath = `/v1/transmems/{tmId}/cleanup`
                .replace(`{${"tmId"}}`, encodeURIComponent(String(tmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new translation memory
         * @param {CreateTransMem} [createTransMem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createTransMem?: CreateTransMem, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/transmems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransMem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new translation memory by uploading tmx file
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithFile: async (file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createWithFile', 'file', file)
            const localVarPath = `/v1/transmems/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get translation memory info by id
         * @param {string} tmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (tmId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tmId' is not null or undefined
            assertParamExists('get', 'tmId', tmId)
            const localVarPath = `/v1/transmems/{tmId}`
                .replace(`{${"tmId"}}`, encodeURIComponent(String(tmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import a translation memory from tmx file
         * @param {string} tmId 
         * @param {object} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importTmx: async (tmId: string, file: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tmId' is not null or undefined
            assertParamExists('importTmx', 'tmId', tmId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('importTmx', 'file', file)
            const localVarPath = `/v1/transmems/{tmId}/import`
                .replace(`{${"tmId"}}`, encodeURIComponent(String(tmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', new Blob([JSON.stringify(file)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all available translation memories or create default one if there is no translation memory
         * @param {number} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTM: async (projectId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/transmems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a translation memory
         * @param {string} tmId 
         * @param {UpdateTransMem} [updateTransMem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (tmId: string, updateTransMem?: UpdateTransMem, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tmId' is not null or undefined
            assertParamExists('update', 'tmId', tmId)
            const localVarPath = `/v1/transmems/{tmId}`
                .replace(`{${"tmId"}}`, encodeURIComponent(String(tmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTransMem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransmemApi - functional programming interface
 * @export
 */
export const TransmemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransmemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a translation memory by id
         * @param {string} tmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(tmId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransMem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(tmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Export translation memory tmx file
         * @param {string} tmId 
         * @param {ExportFormat} [format] 
         * @param {string} [sourceLang] 
         * @param {Array<string>} [targetLangs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _export(tmId: string, format?: ExportFormat, sourceLang?: string, targetLangs?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._export(tmId, format, sourceLang, targetLangs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Erases all the translation data of the provided tmId
         * @param {string} tmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanup(tmId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanup(tmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new translation memory
         * @param {CreateTransMem} [createTransMem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createTransMem?: CreateTransMem, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransMem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(createTransMem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new translation memory by uploading tmx file
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWithFile(file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransMem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWithFile(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get translation memory info by id
         * @param {string} tmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(tmId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransMem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(tmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import a translation memory from tmx file
         * @param {string} tmId 
         * @param {object} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importTmx(tmId: string, file: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importTmx(tmId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all available translation memories or create default one if there is no translation memory
         * @param {number} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTM(projectId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransMem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTM(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a translation memory
         * @param {string} tmId 
         * @param {UpdateTransMem} [updateTransMem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(tmId: string, updateTransMem?: UpdateTransMem, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransMem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(tmId, updateTransMem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransmemApi - factory interface
 * @export
 */
export const TransmemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransmemApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a translation memory by id
         * @param {string} tmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(tmId: string, options?: any): AxiosPromise<TransMem> {
            return localVarFp._delete(tmId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export translation memory tmx file
         * @param {string} tmId 
         * @param {ExportFormat} [format] 
         * @param {string} [sourceLang] 
         * @param {Array<string>} [targetLangs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export(tmId: string, format?: ExportFormat, sourceLang?: string, targetLangs?: Array<string>, options?: any): AxiosPromise<File> {
            return localVarFp._export(tmId, format, sourceLang, targetLangs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Erases all the translation data of the provided tmId
         * @param {string} tmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanup(tmId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cleanup(tmId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new translation memory
         * @param {CreateTransMem} [createTransMem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createTransMem?: CreateTransMem, options?: any): AxiosPromise<TransMem> {
            return localVarFp.create(createTransMem, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new translation memory by uploading tmx file
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithFile(file: File, options?: any): AxiosPromise<TransMem> {
            return localVarFp.createWithFile(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get translation memory info by id
         * @param {string} tmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(tmId: string, options?: any): AxiosPromise<TransMem> {
            return localVarFp.get(tmId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import a translation memory from tmx file
         * @param {string} tmId 
         * @param {object} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importTmx(tmId: string, file: object, options?: any): AxiosPromise<void> {
            return localVarFp.importTmx(tmId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all available translation memories or create default one if there is no translation memory
         * @param {number} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTM(projectId?: number, options?: any): AxiosPromise<Array<TransMem>> {
            return localVarFp.listTM(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a translation memory
         * @param {string} tmId 
         * @param {UpdateTransMem} [updateTransMem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(tmId: string, updateTransMem?: UpdateTransMem, options?: any): AxiosPromise<TransMem> {
            return localVarFp.update(tmId, updateTransMem, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransmemApi - object-oriented interface
 * @export
 * @class TransmemApi
 * @extends {BaseAPI}
 */
export class TransmemApi extends BaseAPI {
    /**
     * 
     * @summary Delete a translation memory by id
     * @param {string} tmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransmemApi
     */
    public _delete(tmId: string, options?: AxiosRequestConfig) {
        return TransmemApiFp(this.configuration)._delete(tmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export translation memory tmx file
     * @param {string} tmId 
     * @param {ExportFormat} [format] 
     * @param {string} [sourceLang] 
     * @param {Array<string>} [targetLangs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransmemApi
     */
    public _export(tmId: string, format?: ExportFormat, sourceLang?: string, targetLangs?: Array<string>, options?: AxiosRequestConfig) {
        return TransmemApiFp(this.configuration)._export(tmId, format, sourceLang, targetLangs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Erases all the translation data of the provided tmId
     * @param {string} tmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransmemApi
     */
    public cleanup(tmId: string, options?: AxiosRequestConfig) {
        return TransmemApiFp(this.configuration).cleanup(tmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new translation memory
     * @param {CreateTransMem} [createTransMem] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransmemApi
     */
    public create(createTransMem?: CreateTransMem, options?: AxiosRequestConfig) {
        return TransmemApiFp(this.configuration).create(createTransMem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new translation memory by uploading tmx file
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransmemApi
     */
    public createWithFile(file: File, options?: AxiosRequestConfig) {
        return TransmemApiFp(this.configuration).createWithFile(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get translation memory info by id
     * @param {string} tmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransmemApi
     */
    public get(tmId: string, options?: AxiosRequestConfig) {
        return TransmemApiFp(this.configuration).get(tmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import a translation memory from tmx file
     * @param {string} tmId 
     * @param {object} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransmemApi
     */
    public importTmx(tmId: string, file: object, options?: AxiosRequestConfig) {
        return TransmemApiFp(this.configuration).importTmx(tmId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all available translation memories or create default one if there is no translation memory
     * @param {number} [projectId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransmemApi
     */
    public listTM(projectId?: number, options?: AxiosRequestConfig) {
        return TransmemApiFp(this.configuration).listTM(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a translation memory
     * @param {string} tmId 
     * @param {UpdateTransMem} [updateTransMem] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransmemApi
     */
    public update(tmId: string, updateTransMem?: UpdateTransMem, options?: AxiosRequestConfig) {
        return TransmemApiFp(this.configuration).update(tmId, updateTransMem, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ViewApi - axios parameter creator
 * @export
 */
export const ViewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * export
         * @summary export
         * @param {string} viewId viewId
         * @param {Array<string>} [columnIds] columnIds
         * @param {ExportFileHeader} [fileHeader] fileHeader
         * @param {string} [query] query
         * @param {string} [sort] sort
         * @param {'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html'} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export: async (viewId: string, columnIds?: Array<string>, fileHeader?: ExportFileHeader, query?: string, sort?: string, type?: 'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('_export', 'viewId', viewId)
            const localVarPath = `/v1/views/{viewId}/export`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (columnIds) {
                localVarQueryParameter['columnIds'] = columnIds;
            }

            if (fileHeader !== undefined) {
                localVarQueryParameter['fileHeader'] = fileHeader;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create
         * @summary create
         * @param {CreateView} createView 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createView: CreateView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createView' is not null or undefined
            assertParamExists('create', 'createView', createView)
            const localVarPath = `/v1/views`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get
         * @summary get
         * @param {string} viewId viewId
         * @param {Array<string>} [columnIds] columnIds
         * @param {Array<'records'>} [include] include
         * @param {string} [page] page
         * @param {string} [query] query
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (viewId: string, columnIds?: Array<string>, include?: Array<'records'>, page?: string, query?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('get', 'viewId', viewId)
            const localVarPath = `/v1/views/{viewId}`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (columnIds) {
                localVarQueryParameter['columnIds'] = columnIds;
            }

            if (include) {
                localVarQueryParameter['include'] = include;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * getStatistic
         * @summary getStatistic
         * @param {string} viewId viewId
         * @param {Array<string>} [columnIds] columnIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatistic: async (viewId: string, columnIds?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('getStatistic', 'viewId', viewId)
            const localVarPath = `/v1/views/{viewId}/statistic`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (columnIds) {
                localVarQueryParameter['columnIds'] = columnIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * importView
         * @summary importView
         * @param {string} viewId viewId
         * @param {File} file The following file types are supported: csv, tsv, xls, xlsx and json
         * @param {string} [importRequest] importRequest
         * @param {'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html'} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importView: async (viewId: string, file: File, importRequest?: string, type?: 'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('importView', 'viewId', viewId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('importView', 'file', file)
            const localVarPath = `/v1/views/{viewId}/import`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (importRequest !== undefined) {
                localVarQueryParameter['importRequest'] = importRequest;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list
         * @summary list
         * @param {string} [branchId] branchId
         * @param {string} [gridId] gridId
         * @param {'defaultView' | 'accessView' | 'userView' | 'workflowView'} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (branchId?: string, gridId?: string, type?: 'defaultView' | 'accessView' | 'userView' | 'workflowView', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/views`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (branchId !== undefined) {
                localVarQueryParameter['branchId'] = branchId;
            }

            if (gridId !== undefined) {
                localVarQueryParameter['gridId'] = gridId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * merge
         * @summary merge
         * @param {string} destinationViewId destinationViewId
         * @param {string} viewId viewId
         * @param {MergeBranchRequest} mergeBranchRequest 
         * @param {Array<'add' | 'update' | 'delete' | 'override'>} [mergeRecordOptions] mergeRecordOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        merge: async (destinationViewId: string, viewId: string, mergeBranchRequest: MergeBranchRequest, mergeRecordOptions?: Array<'add' | 'update' | 'delete' | 'override'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationViewId' is not null or undefined
            assertParamExists('merge', 'destinationViewId', destinationViewId)
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('merge', 'viewId', viewId)
            // verify required parameter 'mergeBranchRequest' is not null or undefined
            assertParamExists('merge', 'mergeBranchRequest', mergeBranchRequest)
            const localVarPath = `/v1/views/{viewId}/merge`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (destinationViewId !== undefined) {
                localVarQueryParameter['destinationViewId'] = destinationViewId;
            }

            if (mergeRecordOptions) {
                localVarQueryParameter['mergeRecordOptions'] = mergeRecordOptions;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mergeBranchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewApi - functional programming interface
 * @export
 */
export const ViewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewApiAxiosParamCreator(configuration)
    return {
        /**
         * export
         * @summary export
         * @param {string} viewId viewId
         * @param {Array<string>} [columnIds] columnIds
         * @param {ExportFileHeader} [fileHeader] fileHeader
         * @param {string} [query] query
         * @param {string} [sort] sort
         * @param {'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html'} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _export(viewId: string, columnIds?: Array<string>, fileHeader?: ExportFileHeader, query?: string, sort?: string, type?: 'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._export(viewId, columnIds, fileHeader, query, sort, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create
         * @summary create
         * @param {CreateView} createView 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createView: CreateView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<View>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(createView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get
         * @summary get
         * @param {string} viewId viewId
         * @param {Array<string>} [columnIds] columnIds
         * @param {Array<'records'>} [include] include
         * @param {string} [page] page
         * @param {string} [query] query
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(viewId: string, columnIds?: Array<string>, include?: Array<'records'>, page?: string, query?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<View>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(viewId, columnIds, include, page, query, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * getStatistic
         * @summary getStatistic
         * @param {string} viewId viewId
         * @param {Array<string>} [columnIds] columnIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatistic(viewId: string, columnIds?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewStatistic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatistic(viewId, columnIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * importView
         * @summary importView
         * @param {string} viewId viewId
         * @param {File} file The following file types are supported: csv, tsv, xls, xlsx and json
         * @param {string} [importRequest] importRequest
         * @param {'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html'} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importView(viewId: string, file: File, importRequest?: string, type?: 'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importView(viewId, file, importRequest, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * list
         * @summary list
         * @param {string} [branchId] branchId
         * @param {string} [gridId] gridId
         * @param {'defaultView' | 'accessView' | 'userView' | 'workflowView'} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(branchId?: string, gridId?: string, type?: 'defaultView' | 'accessView' | 'userView' | 'workflowView', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<View>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(branchId, gridId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * merge
         * @summary merge
         * @param {string} destinationViewId destinationViewId
         * @param {string} viewId viewId
         * @param {MergeBranchRequest} mergeBranchRequest 
         * @param {Array<'add' | 'update' | 'delete' | 'override'>} [mergeRecordOptions] mergeRecordOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async merge(destinationViewId: string, viewId: string, mergeBranchRequest: MergeBranchRequest, mergeRecordOptions?: Array<'add' | 'update' | 'delete' | 'override'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.merge(destinationViewId, viewId, mergeBranchRequest, mergeRecordOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewApi - factory interface
 * @export
 */
export const ViewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewApiFp(configuration)
    return {
        /**
         * export
         * @summary export
         * @param {string} viewId viewId
         * @param {Array<string>} [columnIds] columnIds
         * @param {ExportFileHeader} [fileHeader] fileHeader
         * @param {string} [query] query
         * @param {string} [sort] sort
         * @param {'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html'} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export(viewId: string, columnIds?: Array<string>, fileHeader?: ExportFileHeader, query?: string, sort?: string, type?: 'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html', options?: any): AxiosPromise<File> {
            return localVarFp._export(viewId, columnIds, fileHeader, query, sort, type, options).then((request) => request(axios, basePath));
        },
        /**
         * create
         * @summary create
         * @param {CreateView} createView 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createView: CreateView, options?: any): AxiosPromise<View> {
            return localVarFp.create(createView, options).then((request) => request(axios, basePath));
        },
        /**
         * get
         * @summary get
         * @param {string} viewId viewId
         * @param {Array<string>} [columnIds] columnIds
         * @param {Array<'records'>} [include] include
         * @param {string} [page] page
         * @param {string} [query] query
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(viewId: string, columnIds?: Array<string>, include?: Array<'records'>, page?: string, query?: string, sort?: string, options?: any): AxiosPromise<View> {
            return localVarFp.get(viewId, columnIds, include, page, query, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * getStatistic
         * @summary getStatistic
         * @param {string} viewId viewId
         * @param {Array<string>} [columnIds] columnIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatistic(viewId: string, columnIds?: Array<string>, options?: any): AxiosPromise<ViewStatistic> {
            return localVarFp.getStatistic(viewId, columnIds, options).then((request) => request(axios, basePath));
        },
        /**
         * importView
         * @summary importView
         * @param {string} viewId viewId
         * @param {File} file The following file types are supported: csv, tsv, xls, xlsx and json
         * @param {string} [importRequest] importRequest
         * @param {'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html'} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importView(viewId: string, file: File, importRequest?: string, type?: 'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html', options?: any): AxiosPromise<void> {
            return localVarFp.importView(viewId, file, importRequest, type, options).then((request) => request(axios, basePath));
        },
        /**
         * list
         * @summary list
         * @param {string} [branchId] branchId
         * @param {string} [gridId] gridId
         * @param {'defaultView' | 'accessView' | 'userView' | 'workflowView'} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(branchId?: string, gridId?: string, type?: 'defaultView' | 'accessView' | 'userView' | 'workflowView', options?: any): AxiosPromise<Array<View>> {
            return localVarFp.list(branchId, gridId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * merge
         * @summary merge
         * @param {string} destinationViewId destinationViewId
         * @param {string} viewId viewId
         * @param {MergeBranchRequest} mergeBranchRequest 
         * @param {Array<'add' | 'update' | 'delete' | 'override'>} [mergeRecordOptions] mergeRecordOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        merge(destinationViewId: string, viewId: string, mergeBranchRequest: MergeBranchRequest, mergeRecordOptions?: Array<'add' | 'update' | 'delete' | 'override'>, options?: any): AxiosPromise<Task> {
            return localVarFp.merge(destinationViewId, viewId, mergeBranchRequest, mergeRecordOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ViewApi - object-oriented interface
 * @export
 * @class ViewApi
 * @extends {BaseAPI}
 */
export class ViewApi extends BaseAPI {
    /**
     * export
     * @summary export
     * @param {string} viewId viewId
     * @param {Array<string>} [columnIds] columnIds
     * @param {ExportFileHeader} [fileHeader] fileHeader
     * @param {string} [query] query
     * @param {string} [sort] sort
     * @param {'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html'} [type] type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public _export(viewId: string, columnIds?: Array<string>, fileHeader?: ExportFileHeader, query?: string, sort?: string, type?: 'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html', options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration)._export(viewId, columnIds, fileHeader, query, sort, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create
     * @summary create
     * @param {CreateView} createView 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public create(createView: CreateView, options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration).create(createView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get
     * @summary get
     * @param {string} viewId viewId
     * @param {Array<string>} [columnIds] columnIds
     * @param {Array<'records'>} [include] include
     * @param {string} [page] page
     * @param {string} [query] query
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public get(viewId: string, columnIds?: Array<string>, include?: Array<'records'>, page?: string, query?: string, sort?: string, options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration).get(viewId, columnIds, include, page, query, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * getStatistic
     * @summary getStatistic
     * @param {string} viewId viewId
     * @param {Array<string>} [columnIds] columnIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public getStatistic(viewId: string, columnIds?: Array<string>, options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration).getStatistic(viewId, columnIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * importView
     * @summary importView
     * @param {string} viewId viewId
     * @param {File} file The following file types are supported: csv, tsv, xls, xlsx and json
     * @param {string} [importRequest] importRequest
     * @param {'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html'} [type] type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public importView(viewId: string, file: File, importRequest?: string, type?: 'csv' | 'tsv' | 'xls' | 'xlsx' | 'json' | 'po' | 'html', options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration).importView(viewId, file, importRequest, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list
     * @summary list
     * @param {string} [branchId] branchId
     * @param {string} [gridId] gridId
     * @param {'defaultView' | 'accessView' | 'userView' | 'workflowView'} [type] type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public list(branchId?: string, gridId?: string, type?: 'defaultView' | 'accessView' | 'userView' | 'workflowView', options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration).list(branchId, gridId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * merge
     * @summary merge
     * @param {string} destinationViewId destinationViewId
     * @param {string} viewId viewId
     * @param {MergeBranchRequest} mergeBranchRequest 
     * @param {Array<'add' | 'update' | 'delete' | 'override'>} [mergeRecordOptions] mergeRecordOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public merge(destinationViewId: string, viewId: string, mergeBranchRequest: MergeBranchRequest, mergeRecordOptions?: Array<'add' | 'update' | 'delete' | 'override'>, options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration).merge(destinationViewId, viewId, mergeBranchRequest, mergeRecordOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ViewColumnApi - axios parameter creator
 * @export
 */
export const ViewColumnApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete
         * @summary delete
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (columnId: string, viewId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnId' is not null or undefined
            assertParamExists('_delete', 'columnId', columnId)
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('_delete', 'viewId', viewId)
            const localVarPath = `/v1/views/{viewId}/columns/{columnId}`
                .replace(`{${"columnId"}}`, encodeURIComponent(String(columnId)))
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * add
         * @summary add
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add: async (columnId: string, viewId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnId' is not null or undefined
            assertParamExists('add', 'columnId', columnId)
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('add', 'viewId', viewId)
            const localVarPath = `/v1/views/{viewId}/columns/{columnId}/add`
                .replace(`{${"columnId"}}`, encodeURIComponent(String(columnId)))
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * bulkCreate
         * @summary bulkCreate
         * @param {string} viewId viewId
         * @param {Array<CreateColumn>} createColumn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreate: async (viewId: string, createColumn: Array<CreateColumn>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('bulkCreate', 'viewId', viewId)
            // verify required parameter 'createColumn' is not null or undefined
            assertParamExists('bulkCreate', 'createColumn', createColumn)
            const localVarPath = `/v1/views/{viewId}/columns/bulk`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createColumn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Column
         * @summary create
         * @param {string} viewId viewId
         * @param {CreateColumn} createColumn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (viewId: string, createColumn: CreateColumn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('create', 'viewId', viewId)
            // verify required parameter 'createColumn' is not null or undefined
            assertParamExists('create', 'createColumn', createColumn)
            const localVarPath = `/v1/views/{viewId}/columns`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createColumn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get
         * @summary get
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (columnId: string, viewId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnId' is not null or undefined
            assertParamExists('get', 'columnId', columnId)
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('get', 'viewId', viewId)
            const localVarPath = `/v1/views/{viewId}/columns/{columnId}`
                .replace(`{${"columnId"}}`, encodeURIComponent(String(columnId)))
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * remove
         * @summary remove
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (columnId: string, viewId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnId' is not null or undefined
            assertParamExists('remove', 'columnId', columnId)
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('remove', 'viewId', viewId)
            const localVarPath = `/v1/views/{viewId}/columns/{columnId}/remove`
                .replace(`{${"columnId"}}`, encodeURIComponent(String(columnId)))
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update
         * @summary update
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {UpdateColumn} updateColumn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (columnId: string, viewId: string, updateColumn: UpdateColumn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnId' is not null or undefined
            assertParamExists('update', 'columnId', columnId)
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('update', 'viewId', viewId)
            // verify required parameter 'updateColumn' is not null or undefined
            assertParamExists('update', 'updateColumn', updateColumn)
            const localVarPath = `/v1/views/{viewId}/columns/{columnId}`
                .replace(`{${"columnId"}}`, encodeURIComponent(String(columnId)))
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateColumn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewColumnApi - functional programming interface
 * @export
 */
export const ViewColumnApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewColumnApiAxiosParamCreator(configuration)
    return {
        /**
         * delete
         * @summary delete
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(columnId: string, viewId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(columnId, viewId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * add
         * @summary add
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async add(columnId: string, viewId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewColumn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.add(columnId, viewId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * bulkCreate
         * @summary bulkCreate
         * @param {string} viewId viewId
         * @param {Array<CreateColumn>} createColumn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkCreate(viewId: string, createColumn: Array<CreateColumn>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ViewColumn>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreate(viewId, createColumn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Column
         * @summary create
         * @param {string} viewId viewId
         * @param {CreateColumn} createColumn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(viewId: string, createColumn: CreateColumn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewColumn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(viewId, createColumn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get
         * @summary get
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(columnId: string, viewId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewColumn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(columnId, viewId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * remove
         * @summary remove
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(columnId: string, viewId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(columnId, viewId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update
         * @summary update
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {UpdateColumn} updateColumn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(columnId: string, viewId: string, updateColumn: UpdateColumn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewColumn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(columnId, viewId, updateColumn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewColumnApi - factory interface
 * @export
 */
export const ViewColumnApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewColumnApiFp(configuration)
    return {
        /**
         * delete
         * @summary delete
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(columnId: string, viewId: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(columnId, viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * add
         * @summary add
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(columnId: string, viewId: string, options?: any): AxiosPromise<ViewColumn> {
            return localVarFp.add(columnId, viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * bulkCreate
         * @summary bulkCreate
         * @param {string} viewId viewId
         * @param {Array<CreateColumn>} createColumn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreate(viewId: string, createColumn: Array<CreateColumn>, options?: any): AxiosPromise<Array<ViewColumn>> {
            return localVarFp.bulkCreate(viewId, createColumn, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Column
         * @summary create
         * @param {string} viewId viewId
         * @param {CreateColumn} createColumn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(viewId: string, createColumn: CreateColumn, options?: any): AxiosPromise<ViewColumn> {
            return localVarFp.create(viewId, createColumn, options).then((request) => request(axios, basePath));
        },
        /**
         * get
         * @summary get
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(columnId: string, viewId: string, options?: any): AxiosPromise<ViewColumn> {
            return localVarFp.get(columnId, viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * remove
         * @summary remove
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(columnId: string, viewId: string, options?: any): AxiosPromise<void> {
            return localVarFp.remove(columnId, viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * update
         * @summary update
         * @param {string} columnId columnId
         * @param {string} viewId viewId
         * @param {UpdateColumn} updateColumn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(columnId: string, viewId: string, updateColumn: UpdateColumn, options?: any): AxiosPromise<ViewColumn> {
            return localVarFp.update(columnId, viewId, updateColumn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ViewColumnApi - object-oriented interface
 * @export
 * @class ViewColumnApi
 * @extends {BaseAPI}
 */
export class ViewColumnApi extends BaseAPI {
    /**
     * delete
     * @summary delete
     * @param {string} columnId columnId
     * @param {string} viewId viewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewColumnApi
     */
    public _delete(columnId: string, viewId: string, options?: AxiosRequestConfig) {
        return ViewColumnApiFp(this.configuration)._delete(columnId, viewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * add
     * @summary add
     * @param {string} columnId columnId
     * @param {string} viewId viewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewColumnApi
     */
    public add(columnId: string, viewId: string, options?: AxiosRequestConfig) {
        return ViewColumnApiFp(this.configuration).add(columnId, viewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * bulkCreate
     * @summary bulkCreate
     * @param {string} viewId viewId
     * @param {Array<CreateColumn>} createColumn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewColumnApi
     */
    public bulkCreate(viewId: string, createColumn: Array<CreateColumn>, options?: AxiosRequestConfig) {
        return ViewColumnApiFp(this.configuration).bulkCreate(viewId, createColumn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Column
     * @summary create
     * @param {string} viewId viewId
     * @param {CreateColumn} createColumn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewColumnApi
     */
    public create(viewId: string, createColumn: CreateColumn, options?: AxiosRequestConfig) {
        return ViewColumnApiFp(this.configuration).create(viewId, createColumn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get
     * @summary get
     * @param {string} columnId columnId
     * @param {string} viewId viewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewColumnApi
     */
    public get(columnId: string, viewId: string, options?: AxiosRequestConfig) {
        return ViewColumnApiFp(this.configuration).get(columnId, viewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * remove
     * @summary remove
     * @param {string} columnId columnId
     * @param {string} viewId viewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewColumnApi
     */
    public remove(columnId: string, viewId: string, options?: AxiosRequestConfig) {
        return ViewColumnApiFp(this.configuration).remove(columnId, viewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update
     * @summary update
     * @param {string} columnId columnId
     * @param {string} viewId viewId
     * @param {UpdateColumn} updateColumn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewColumnApi
     */
    public update(columnId: string, viewId: string, updateColumn: UpdateColumn, options?: AxiosRequestConfig) {
        return ViewColumnApiFp(this.configuration).update(columnId, viewId, updateColumn, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ViewDependencyApi - axios parameter creator
 * @export
 */
export const ViewDependencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete
         * @summary delete
         * @param {string} viewId viewId
         * @param {DeleteDependency} deleteDependency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (viewId: string, deleteDependency: DeleteDependency, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('_delete', 'viewId', viewId)
            // verify required parameter 'deleteDependency' is not null or undefined
            assertParamExists('_delete', 'deleteDependency', deleteDependency)
            const localVarPath = `/v1/views/{viewId}/dependencies`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteDependency, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create
         * @summary create
         * @param {string} viewId viewId
         * @param {CreateDependency} createDependency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (viewId: string, createDependency: CreateDependency, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('create', 'viewId', viewId)
            // verify required parameter 'createDependency' is not null or undefined
            assertParamExists('create', 'createDependency', createDependency)
            const localVarPath = `/v1/views/{viewId}/dependencies`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDependency, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * deleteById
         * @summary deleteById
         * @param {string} viewId viewId
         * @param {string} dependencyId dependencyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById: async (viewId: string, dependencyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('deleteById', 'viewId', viewId)
            // verify required parameter 'dependencyId' is not null or undefined
            assertParamExists('deleteById', 'dependencyId', dependencyId)
            const localVarPath = `/v1/views/{viewId}/dependencies/{dependencyId}`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)))
                .replace(`{${"dependencyId"}}`, encodeURIComponent(String(dependencyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get
         * @summary get
         * @param {string} dependencyId dependencyId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (dependencyId: string, viewId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dependencyId' is not null or undefined
            assertParamExists('get', 'dependencyId', dependencyId)
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('get', 'viewId', viewId)
            const localVarPath = `/v1/views/{viewId}/dependencies/{dependencyId}`
                .replace(`{${"dependencyId"}}`, encodeURIComponent(String(dependencyId)))
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list
         * @summary list
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (viewId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('list', 'viewId', viewId)
            const localVarPath = `/v1/views/{viewId}/dependencies`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update
         * @summary update
         * @param {string} dependencyId dependencyId
         * @param {string} viewId viewId
         * @param {UpdateDependency} updateDependency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (dependencyId: string, viewId: string, updateDependency: UpdateDependency, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dependencyId' is not null or undefined
            assertParamExists('update', 'dependencyId', dependencyId)
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('update', 'viewId', viewId)
            // verify required parameter 'updateDependency' is not null or undefined
            assertParamExists('update', 'updateDependency', updateDependency)
            const localVarPath = `/v1/views/{viewId}/dependencies/{dependencyId}`
                .replace(`{${"dependencyId"}}`, encodeURIComponent(String(dependencyId)))
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDependency, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewDependencyApi - functional programming interface
 * @export
 */
export const ViewDependencyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewDependencyApiAxiosParamCreator(configuration)
    return {
        /**
         * delete
         * @summary delete
         * @param {string} viewId viewId
         * @param {DeleteDependency} deleteDependency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(viewId: string, deleteDependency: DeleteDependency, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(viewId, deleteDependency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create
         * @summary create
         * @param {string} viewId viewId
         * @param {CreateDependency} createDependency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(viewId: string, createDependency: CreateDependency, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dependency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(viewId, createDependency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * deleteById
         * @summary deleteById
         * @param {string} viewId viewId
         * @param {string} dependencyId dependencyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteById(viewId: string, dependencyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteById(viewId, dependencyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get
         * @summary get
         * @param {string} dependencyId dependencyId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(dependencyId: string, viewId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dependency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(dependencyId, viewId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * list
         * @summary list
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(viewId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dependency>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(viewId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update
         * @summary update
         * @param {string} dependencyId dependencyId
         * @param {string} viewId viewId
         * @param {UpdateDependency} updateDependency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(dependencyId: string, viewId: string, updateDependency: UpdateDependency, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dependency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(dependencyId, viewId, updateDependency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewDependencyApi - factory interface
 * @export
 */
export const ViewDependencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewDependencyApiFp(configuration)
    return {
        /**
         * delete
         * @summary delete
         * @param {string} viewId viewId
         * @param {DeleteDependency} deleteDependency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(viewId: string, deleteDependency: DeleteDependency, options?: any): AxiosPromise<void> {
            return localVarFp._delete(viewId, deleteDependency, options).then((request) => request(axios, basePath));
        },
        /**
         * create
         * @summary create
         * @param {string} viewId viewId
         * @param {CreateDependency} createDependency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(viewId: string, createDependency: CreateDependency, options?: any): AxiosPromise<Dependency> {
            return localVarFp.create(viewId, createDependency, options).then((request) => request(axios, basePath));
        },
        /**
         * deleteById
         * @summary deleteById
         * @param {string} viewId viewId
         * @param {string} dependencyId dependencyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById(viewId: string, dependencyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteById(viewId, dependencyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get
         * @summary get
         * @param {string} dependencyId dependencyId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(dependencyId: string, viewId: string, options?: any): AxiosPromise<Dependency> {
            return localVarFp.get(dependencyId, viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * list
         * @summary list
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(viewId: string, options?: any): AxiosPromise<Array<Dependency>> {
            return localVarFp.list(viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * update
         * @summary update
         * @param {string} dependencyId dependencyId
         * @param {string} viewId viewId
         * @param {UpdateDependency} updateDependency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(dependencyId: string, viewId: string, updateDependency: UpdateDependency, options?: any): AxiosPromise<Dependency> {
            return localVarFp.update(dependencyId, viewId, updateDependency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ViewDependencyApi - object-oriented interface
 * @export
 * @class ViewDependencyApi
 * @extends {BaseAPI}
 */
export class ViewDependencyApi extends BaseAPI {
    /**
     * delete
     * @summary delete
     * @param {string} viewId viewId
     * @param {DeleteDependency} deleteDependency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewDependencyApi
     */
    public _delete(viewId: string, deleteDependency: DeleteDependency, options?: AxiosRequestConfig) {
        return ViewDependencyApiFp(this.configuration)._delete(viewId, deleteDependency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create
     * @summary create
     * @param {string} viewId viewId
     * @param {CreateDependency} createDependency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewDependencyApi
     */
    public create(viewId: string, createDependency: CreateDependency, options?: AxiosRequestConfig) {
        return ViewDependencyApiFp(this.configuration).create(viewId, createDependency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * deleteById
     * @summary deleteById
     * @param {string} viewId viewId
     * @param {string} dependencyId dependencyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewDependencyApi
     */
    public deleteById(viewId: string, dependencyId: string, options?: AxiosRequestConfig) {
        return ViewDependencyApiFp(this.configuration).deleteById(viewId, dependencyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get
     * @summary get
     * @param {string} dependencyId dependencyId
     * @param {string} viewId viewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewDependencyApi
     */
    public get(dependencyId: string, viewId: string, options?: AxiosRequestConfig) {
        return ViewDependencyApiFp(this.configuration).get(dependencyId, viewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list
     * @summary list
     * @param {string} viewId viewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewDependencyApi
     */
    public list(viewId: string, options?: AxiosRequestConfig) {
        return ViewDependencyApiFp(this.configuration).list(viewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update
     * @summary update
     * @param {string} dependencyId dependencyId
     * @param {string} viewId viewId
     * @param {UpdateDependency} updateDependency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewDependencyApi
     */
    public update(dependencyId: string, viewId: string, updateDependency: UpdateDependency, options?: AxiosRequestConfig) {
        return ViewDependencyApiFp(this.configuration).update(dependencyId, viewId, updateDependency, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ViewFileApi - axios parameter creator
 * @export
 */
export const ViewFileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete
         * @summary delete
         * @param {string} columnId columnId
         * @param {string} recordId recordId
         * @param {string} viewId viewId
         * @param {DeleteFile} deleteFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (columnId: string, recordId: string, viewId: string, deleteFile: DeleteFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnId' is not null or undefined
            assertParamExists('_delete', 'columnId', columnId)
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('_delete', 'recordId', recordId)
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('_delete', 'viewId', viewId)
            // verify required parameter 'deleteFile' is not null or undefined
            assertParamExists('_delete', 'deleteFile', deleteFile)
            const localVarPath = `/v1/views/{viewId}/files`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (columnId !== undefined) {
                localVarQueryParameter['columnId'] = columnId;
            }

            if (recordId !== undefined) {
                localVarQueryParameter['recordId'] = recordId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * download
         * @summary download
         * @param {string} fileId fileId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download: async (fileId: string, viewId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('download', 'fileId', fileId)
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('download', 'viewId', viewId)
            const localVarPath = `/v1/views/{viewId}/files/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * upload
         * @summary upload
         * @param {string} viewId viewId
         * @param {string} columnId columnId
         * @param {string} recordId recordId
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload: async (viewId: string, columnId: string, recordId: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('upload', 'viewId', viewId)
            // verify required parameter 'columnId' is not null or undefined
            assertParamExists('upload', 'columnId', columnId)
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('upload', 'recordId', recordId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('upload', 'file', file)
            const localVarPath = `/v1/views/{viewId}/files`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (columnId !== undefined) {
                localVarQueryParameter['columnId'] = columnId;
            }

            if (recordId !== undefined) {
                localVarQueryParameter['recordId'] = recordId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * uploadZip
         * @summary uploadZip
         * @param {string} viewId viewId
         * @param {string} columnId 
         * @param {string} fileMappings 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadZip: async (viewId: string, columnId: string, fileMappings: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('uploadZip', 'viewId', viewId)
            // verify required parameter 'columnId' is not null or undefined
            assertParamExists('uploadZip', 'columnId', columnId)
            // verify required parameter 'fileMappings' is not null or undefined
            assertParamExists('uploadZip', 'fileMappings', fileMappings)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadZip', 'file', file)
            const localVarPath = `/v1/views/{viewId}/files/zip`
                .replace(`{${"viewId"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (columnId !== undefined) { 
                localVarFormParams.append('columnId', columnId as any);
            }
    
            if (fileMappings !== undefined) { 
                localVarFormParams.append('fileMappings', fileMappings as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewFileApi - functional programming interface
 * @export
 */
export const ViewFileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewFileApiAxiosParamCreator(configuration)
    return {
        /**
         * delete
         * @summary delete
         * @param {string} columnId columnId
         * @param {string} recordId recordId
         * @param {string} viewId viewId
         * @param {DeleteFile} deleteFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(columnId: string, recordId: string, viewId: string, deleteFile: DeleteFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(columnId, recordId, viewId, deleteFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * download
         * @summary download
         * @param {string} fileId fileId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download(fileId: string, viewId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.download(fileId, viewId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * upload
         * @summary upload
         * @param {string} viewId viewId
         * @param {string} columnId columnId
         * @param {string} recordId recordId
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload(viewId: string, columnId: string, recordId: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadedFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upload(viewId, columnId, recordId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * uploadZip
         * @summary uploadZip
         * @param {string} viewId viewId
         * @param {string} columnId 
         * @param {string} fileMappings 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadZip(viewId: string, columnId: string, fileMappings: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Record>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadZip(viewId, columnId, fileMappings, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewFileApi - factory interface
 * @export
 */
export const ViewFileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewFileApiFp(configuration)
    return {
        /**
         * delete
         * @summary delete
         * @param {string} columnId columnId
         * @param {string} recordId recordId
         * @param {string} viewId viewId
         * @param {DeleteFile} deleteFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(columnId: string, recordId: string, viewId: string, deleteFile: DeleteFile, options?: any): AxiosPromise<void> {
            return localVarFp._delete(columnId, recordId, viewId, deleteFile, options).then((request) => request(axios, basePath));
        },
        /**
         * download
         * @summary download
         * @param {string} fileId fileId
         * @param {string} viewId viewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(fileId: string, viewId: string, options?: any): AxiosPromise<File> {
            return localVarFp.download(fileId, viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * upload
         * @summary upload
         * @param {string} viewId viewId
         * @param {string} columnId columnId
         * @param {string} recordId recordId
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(viewId: string, columnId: string, recordId: string, file: File, options?: any): AxiosPromise<UploadedFile> {
            return localVarFp.upload(viewId, columnId, recordId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * uploadZip
         * @summary uploadZip
         * @param {string} viewId viewId
         * @param {string} columnId 
         * @param {string} fileMappings 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadZip(viewId: string, columnId: string, fileMappings: string, file: File, options?: any): AxiosPromise<Array<Record>> {
            return localVarFp.uploadZip(viewId, columnId, fileMappings, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ViewFileApi - object-oriented interface
 * @export
 * @class ViewFileApi
 * @extends {BaseAPI}
 */
export class ViewFileApi extends BaseAPI {
    /**
     * delete
     * @summary delete
     * @param {string} columnId columnId
     * @param {string} recordId recordId
     * @param {string} viewId viewId
     * @param {DeleteFile} deleteFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewFileApi
     */
    public _delete(columnId: string, recordId: string, viewId: string, deleteFile: DeleteFile, options?: AxiosRequestConfig) {
        return ViewFileApiFp(this.configuration)._delete(columnId, recordId, viewId, deleteFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * download
     * @summary download
     * @param {string} fileId fileId
     * @param {string} viewId viewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewFileApi
     */
    public download(fileId: string, viewId: string, options?: AxiosRequestConfig) {
        return ViewFileApiFp(this.configuration).download(fileId, viewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * upload
     * @summary upload
     * @param {string} viewId viewId
     * @param {string} columnId columnId
     * @param {string} recordId recordId
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewFileApi
     */
    public upload(viewId: string, columnId: string, recordId: string, file: File, options?: AxiosRequestConfig) {
        return ViewFileApiFp(this.configuration).upload(viewId, columnId, recordId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * uploadZip
     * @summary uploadZip
     * @param {string} viewId viewId
     * @param {string} columnId 
     * @param {string} fileMappings 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewFileApi
     */
    public uploadZip(viewId: string, columnId: string, fileMappings: string, file: File, options?: AxiosRequestConfig) {
        return ViewFileApiFp(this.configuration).uploadZip(viewId, columnId, fileMappings, file, options).then((request) => request(this.axios, this.basePath));
    }
}


